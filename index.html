<!DOCTYPE html>
<html lang="tr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>İnternet Programlama Sınavı - Örnek Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f4f4f4;
        color: #333;
      }
      h1 {
        text-align: center;
        color: #2c3e50;
      }
      #container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      #question-container {
        margin-bottom: 20px;
        opacity: 0;
        animation: fadeIn 0.5s forwards;
      }
      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }
      .option {
        margin: 10px 0;
        padding: 10px;
        background: #ecf0f1;
        border-radius: 5px;
        transition: background 0.3s;
      }
      .option:hover {
        background: #dfe6e9;
      }
      #result,
      #explanation {
        margin: 10px 0;
        padding: 10px;
        border-radius: 5px;
        display: none;
        animation: slideIn 0.5s forwards;
      }
      @keyframes slideIn {
        from {
          transform: translateX(-20px);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }
      #result.correct {
        background: #d4edda;
        color: #155724;
      }
      #result.wrong {
        background: #f8d7da;
        color: #721c24;
      }
      #explanation {
        background: #f1f1f1;
        color: #555;
      }
      button,
      select {
        padding: 10px 20px;
        margin: 5px;
        border: none;
        border-radius: 5px;
        background: #3498db;
        color: white;
        cursor: pointer;
        transition: background 0.3s;
      }
      button:hover,
      select:hover {
        background: #2980b9;
      }
      button:disabled {
        background: #bdc3c7;
        cursor: not-allowed;
      }
      #score-table,
      #tracking-table {
        margin-top: 20px;
        width: 100%;
        border-collapse: collapse;
      }
      #score-table th,
      #tracking-table th,
      #score-table td,
      #tracking-table td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: center;
      }
      #tracking-table {
        max-height: 200px;
        overflow-y: auto;
      }
      .correct {
        background: #d4edda;
      }
      .wrong {
        background: #f8d7da;
      }
      .unattempted {
        background: #fff3cd;
      }
      #final-score {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        text-align: center;
      }
    </style>
  </head>
  <body>
    <h1>İnternet Programlama Sınavı - Örnek Test</h1>
    <div id="container">
      <select id="model-select" onchange="changeModel()">
        <option value="A">Model A(good)</option>
        <option value="B">Model B(meduim)</option>
        <option value="C">Model C(easy)</option>
        <option value="D">Model D(newest)</option>
      </select>
      <div id="question-container"></div>
      <div id="result"></div>
      <div id="explanation"></div>
      <div>
        <button id="prev-btn" onclick="prevQuestion()">Önceki Soru</button>
        <button id="submit-btn" onclick="submitAnswer()">Cevabı Gönder</button>
        <button id="next-btn" onclick="nextQuestion()">Sonraki Soru</button>
        <button id="reset-btn" onclick="resetQuiz()">Sıfırla</button>
      </div>
      <table id="score-table">
        <tr>
          <th>Doğru Sayısı</th>
          <th>Yanlış Sayısı</th>
          <th>Toplam Deneme</th>
        </tr>
        <tr>
          <td id="correct-count">0</td>
          <td id="wrong-count">0</td>
          <td id="attempted-count">0</td>
        </tr>
      </table>
      <table id="tracking-table">
        <thead>
          <tr>
            <th>Soru No</th>
            <th>Durum</th>
          </tr>
        </thead>
        <tbody id="tracking-body"></tbody>
      </table>
    </div>
    <div id="final-score">
      <h2>Sınav Bitti!</h2>
      <p id="final-score-text"></p>
      <button
        onclick="document.getElementById('final-score').style.display='none'"
      >
        Kapat
      </button>
    </div>

    <script>
      const modelA = [
        {
          question:
            'Bir kullanıcı tarayıcısına "www.example.com" yazar ve tarayıcı, sayfayı istemeden önce alanı bir IP adresine çözer. TCP/IP yığınında bu alan adı çözümlemesinden öncelikle hangi katman sorumludur?',
          options: [
            "A) Uygulama Katmanı",
            "B) Taşıma Katmanı",
            "C) İnternet Katmanı",
            "D) Ağ Arayüzü Katmanı",
            "E) Fiziksel Katman",
          ],
          correct: "A) Uygulama Katmanı",
          explanation:
            "DNS çözümlemesi, alan adlarını IP adreslerine çeviren DNS gibi protokollerin çalıştığı Uygulama Katmanında gerçekleşir.",
        },
        {
          question:
            "İstemci-Sunucu modelinde, bir web sunucusu tarayıcı isteğine bir HTML sayfası ile yanıt verdiğinde sunucunun rolü nedir?",
          options: [
            "A) İstemci, ek kaynaklar isteyen",
            "B) Sunucu, istenen içeriği sağlayan",
            "C) Vekil, isteği ileten",
            "D) Çözümleyici, alanı çeviren",
            "E) Ağ Geçidi, yanıtı yönlendiren",
          ],
          correct: "B) Sunucu, istenen içeriği sağlayan",
          explanation:
            "İstemci-Sunucu modelinde sunucu, istemcinin (tarayıcının) isteğine yanıt olarak içerik sağlar.",
        },
        {
          question:
            "Hangi protokol, istemci ile sunucu arasındaki iletişimi şifreleyerek güvenli hale getirir?",
          options: ["A) HTTP", "B) TCP", "C) HTTPS", "D) DNS", "E) IP"],
          correct: "C) HTTPS",
          explanation:
            "HTTPS, verileri şifreleyerek istemci ile sunucu arasında güvenli iletişim sağlar.",
        },
        {
          question:
            "Bir .NET Core konsol uygulamasında, terminalden yeni bir proje oluşturmak için hangi komut kullanılır?",
          options: [
            "A) dotnet run",
            "B) dotnet new console",
            "C) dotnet build",
            "D) dotnet restore",
            "E) dotnet publish",
          ],
          correct: "B) dotnet new console",
          explanation:
            "'dotnet new console', .NET Core'da yeni bir konsol uygulaması projesi oluşturur.",
        },
        {
          question:
            "Bir geliştirici, mevcut değişikliklerini depoya commit etmeden geçici olarak kaydetmek istiyor. Hangi Git komutunu kullanmalıdır?",
          options: [
            "A) git commit",
            "B) git stash",
            "C) git push",
            "D) git branch",
            "E) git merge",
          ],
          correct: "B) git stash",
          explanation:
            "'git stash', değişiklikleri geçici olarak saklar ve çalışma dizinini temizler.",
        },
        {
          question:
            "GitHub gibi bir uzak depoyla çalışırken, uzak depodan güncellemeleri yerel branche birleştirmeden almak için hangi komut kullanılır?",
          options: [
            "A) git pull",
            "B) git fetch",
            "C) git clone",
            "D) git push",
            "E) git remote add",
          ],
          correct: "B) git fetch",
          explanation:
            "'git fetch', uzak depodan güncellemeleri alır ancak yerel branch'e birleştirmez.",
        },
        {
          question:
            "Geçici derleme dosyalarını Git tarafından takip edilmekten hariç tutmak için hangi dosya düzenlenmelidir?",
          options: [
            "A) .gitconfig",
            "B) .gitignore",
            "C) README.md",
            "D) .gitattributes",
            "E) .gitmodules",
          ],
          correct: "B) .gitignore",
          explanation:
            "'.gitignore', Git'in takip etmeyeceği dosyaları belirtmek için kullanılır.",
        },
        {
          question:
            "Bir ekip, Git kullanarak bir özellik üzerinde işbirliği yapıyor. Ana branche değişiklik önermek için en iyi uygulama nedir?",
          options: [
            "A) Doğrudan ana branche push yapmak",
            "B) Özellik branch'inden bir çekme isteği oluşturmak",
            "C) Değişiklikleri yerel olarak commit edip e-posta ile paylaşmak",
            "D) git stash kullanıp değişiklikleri manuel uygulamak",
            "E) Her değişiklik için depoyu yeniden klonlamak",
          ],
          correct: "B) Özellik branch'inden bir çekme isteği oluşturmak",
          explanation:
            "Çekme istekleri, işbirliği için izole değişikliklerin önerilmesini sağlar.",
        },
        {
          question:
            "Bir istemci, bir API'ye mevcut bir kaynağı güncellemek için istek gönderir. HTTP metot semantiğine göre hangi metot kullanılmalıdır?",
          options: ["A) GET", "B) POST", "C) PUT", "D) DELETE", "E) HEAD"],
          correct: "C) PUT",
          explanation: "PUT, mevcut bir kaynağı güncellemek için kullanılır.",
        },
        {
          question:
            "Bir ASP.NET Core uygulaması, sunucu hatası ile sonuçlanan bir istek aldığında hangi HTTP durum kodu sınıfını döndürmelidir?",
          options: ["A) 2xx", "B) 3xx", "C) 4xx", "D) 5xx", "E) 1xx"],
          correct: "D) 5xx",
          explanation:
            "5xx durum kodları, sunucu tarafı hatalarını gösterir (örn. 500 Internal Server Error).",
        },
        {
          question:
            "Bir ASP.NET Core projesinde, istekleri işlemek için ara yazılım hattını hangi dosya tanımlar?",
          options: [
            "A) Startup.cs veya Program.cs",
            "B) appsettings.json",
            "C) Controller.cs",
            "D) launchSettings.json",
            "E) wwwroot/index.html",
          ],
          correct: "A) Startup.cs veya Program.cs",
          explanation:
            "Ara yazılım hattı, Program.cs veya Startup.cs'de yapılandırılır.",
        },
        {
          question:
            "Bir geliştirici, ASP.NET Core uygulamasında her gelen isteği günlüğe kaydetmek istiyor. En iyi yaklaşım nedir?",
          options: [
            "A) Her controllera günlük kodu eklemek",
            "B) Özel bir ara yazılım oluşturup hattına eklemek",
            "C) HTTP yanıtını doğrudan değiştirmek",
            "D) Yalnızca üçüncü taraf bir günlük servisi kullanmak",
            "E) Varsayılan controller şablonunu düzenlemek",
          ],
          correct: "B) Özel bir ara yazılım oluşturup hattına eklemek",
          explanation:
            "Ara yazılım, istekleri merkezi bir şekilde işlemek için idealdir.",
        },
        {
          question:
            "Bir ASP.NET Core uygulamasında bir servis, tek bir kullanıcı oturumu boyunca tüm isteklerde durumu korumalıdır. Hangi servis yaşam süresi kullanılmalıdır?",
          options: [
            "A) Transient",
            "B) Scoped",
            "C) Singleton",
            "D) PerResolve",
            "E) RequestScoped",
          ],
          correct: "B) Scoped",
          explanation:
            "Scoped yaşam süresi, bir HTTP isteği kapsamındaki durumu korur.",
        },
        {
          question:
            "ASP.NET Core'da Bağımlılık Enjeksiyonu (DI) kullanmanın birincil faydası nedir?",
          options: [
            "A) Daha hızlı uygulama başlatma",
            "B) Gevşek bağlılık ve geliştirilmiş test edilebilirlik",
            "C) Azaltılmış bellek kullanımı",
            "D) Basitleştirilmiş yönlendirme",
            "E) Otomatik veritabanı bağlantısı",
          ],
          correct: "B) Gevşek bağlılık ve geliştirilmiş test edilebilirlik",
          explanation:
            "DI, kodun esnekliğini ve test edilebilirliğini artırır.",
        },
        {
          question:
            "Bir ASP.NET Core uygulamasında rota '/products/{id:int}' olarak tanımlanmıştır. ':int' neyi ifade eder?",
          options: [
            "A) Zorunlu bir parametre",
            "B) Bir rota kısıtlaması",
            "C) İsteğe bağlı bir parametre",
            "D) Varsayılan bir değer",
            "E) Bir sorgu dizesi",
          ],
          correct: "B) Bir rota kısıtlaması",
          explanation:
            "':int', id parametresinin tamsayı olması gerektiğini kısıtlar.",
        },
        {
          question:
            "ASP.NET Core'da bir rota eşleşmezse, geliştirici ilk olarak neyi kontrol etmelidir?",
          options: [
            "A) Veritabanı bağlantısını",
            "B) HTTP metodunu ve rota şablon sözdizimini",
            "C) İstemcinin IP adresini",
            "D) Program.cs'deki ara yazılım sırasını",
            "E) Yanıt başlıklarını",
          ],
          correct: "B) HTTP metodunu ve rota şablon sözdizimini",
          explanation:
            "Yanlış metot veya şablon Vastel, eşleşme başarısızlığına neden olabilir.",
        },
        {
          question:
            "Bir ASP.NET Core controller, '/products?searchTerm=book' gibi bir URL'den 'searchTerm' sorgu parametresini almak istiyor. Hangi öznitelik kullanılmalıdır?",
          options: [
            "A) [FromBody]",
            "B) [FromQuery]",
            "C) [FromRoute]",
            "D) [FromHeader]",
            "E) [FromForm]",
          ],
          correct: "B) [FromQuery]",
          explanation: "[FromQuery], sorgu dizesinden parametre bağlar.",
        },
        {
          question:
            "Bir controller eylemi istemciye bir dosya döndürür. Hangi IActionResult metodu kullanılmalıdır?",
          options: [
            "A) Ok()",
            "B) Json()",
            "C) File()",
            "D) Content()",
            "E) StatusCode()",
          ],
          correct: "C) File()",
          explanation:
            "File(), dosya içeriğini istemciye döndürmek için kullanılır.",
        },
        {
          question:
            "ASP.NET Core'da model bağlama başarısız olduğunda, doğrulama hatalarını belirlemek için hangi özellik kontrol edilebilir?",
          options: [
            "A) HttpContext",
            "B) ModelState",
            "C) Request.Headers",
            "D) Response.StatusCode",
            "E) IActionResult",
          ],
          correct: "B) ModelState",
          explanation: "ModelState, bağlama ve doğrulama hatalarını içerir.",
        },
        {
          question:
            "Bir API uç noktası JSON yükü alır ancak bunu bir parametreye bağlayamaz. İlk olarak ne doğrulanmalıdır?",
          options: [
            "A) [FromBody] özniteliğinin mevcut olması",
            "B) Rota şablonunun eşleşmesi",
            "C) Sorgu dizesinin doğru olması",
            "D) Yanıt başlıklarının ayarlanması",
            "E) Ara yazılım sırası",
          ],
          correct: "A) [FromBody] özniteliğinin mevcut olması",
          explanation: "[FromBody], JSON gövdesini bağlamak için gereklidir.",
        },
        {
          question:
            "Bir ASP.NET Core modelinde kullanıcının e-posta adresinin geçerli olmasını sağlamak için hangi veri notasyon özniteliği kullanılmalıdır?",
          options: [
            "A) [Required]",
            "B) [StringLength]",
            "C) [EmailAddress]",
            "D) [Range]",
            "E) [RegularExpression]",
          ],
          correct: "C) [EmailAddress]",
          explanation: "[EmailAddress], e-posta biçimini doğrular.",
        },
        {
          question:
            "Bir API, parolanın karmaşıklık gereksinimlerini (örn. en az 8 karakter ve bir rakam) karşıladığından emin olmalıdır. Bu doğrulama mantığı nerede tanımlanmalıdır?",
          options: [
            "A) Controller eyleminde",
            "B) Özel bir ara yazılımda",
            "C) Model özelliğinde veri notasyonları olarak",
            "D) Program.cs dosyasında",
            "E) Veritabanı şemasında",
          ],
          correct: "C) Model özelliğinde veri notasyonları olarak",
          explanation:
            "Veri notasyonları, doğrulama kurallarını bildirimsel olarak tanımlar.",
        },
        {
          question:
            "Bir API tasarlarken, uç noktaları kaynaklar etrafında yapılandırmak için önerilen yaklaşım nedir?",
          options: [
            "A) URI'lerde fiiller kullanmak (örn. /getProducts)",
            "B) İsimler ve HTTP metotları kullanmak (örn. /products ile GET)",
            "C) Tüm mantığı tek bir uç noktada toplamak",
            "D) Sorgu parametrelerinden kaçınmak",
            "E) Rastgele URI desenleri kullanmak",
          ],
          correct: "B) İsimler ve HTTP metotları kullanmak",
          explanation:
            "Kaynak odaklı tasarım, isimler ve HTTP metotları kullanır.",
        },
        {
          question:
            "Bir API büyük bir veri kümesi döndürür. Bunu verimli bir şekilde nasıl işleyebilir?",
          options: [
            "A) Tüm veriyi tek bir yanıtta döndürmek",
            "B) Sayfa numaraları ile sayfalama uygulamak",
            "C) GET yerine POST isteği kullanmak",
            "D) Sunucu zaman aşımını artırmak",
            "E) Yanıtı manuel olarak sıkıştırmak",
          ],
          correct: "B) Sayfa numaraları ile sayfalama uygulamak",
          explanation:
            "Sayfalama, büyük veri kümelerini verimli bir şekilde yönetir.",
        },
        {
          question:
            "TCP/IP yığınında, bir yanıt Ağ Arayüzü Katmanından Uygulama Katmanına yukarı doğru hareket ettiğinde hangi işlem gerçekleşir?",
          options: [
            "A) Kapsülleme",
            "B) Kapsül Çözme",
            "C) Yönlendirme",
            "D) Çoklama",
            "E) Bölümleme",
          ],
          correct: "B) Kapsül Çözme",
          explanation:
            "Kapsül çözme, verinin yukarı doğru hareket ederken başlıklarının çıkarılmasıdır.",
        },
        {
          question:
            "Bir geliştirici yanlışlıkla hassas verileri bir Git deposuna commit eder. Bunu geçmişten çıkarmak için hangi komut kullanılabilir?",
          options: [
            "A) git reset",
            "B) git revert",
            "C) git rebase",
            "D) git filter-branch",
            "E) git stash",
          ],
          correct: "D) git filter-branch",
          explanation:
            "'git filter-branch', commit geçmişini yeniden yazarak veriyi kaldırır.",
        },
        {
          question:
            "Bir ASP.NET Core API uç noktası '404 Bulunamadı' döndürür. Bu neyi gösterir?",
          options: [
            "A) Sunucu hatası",
            "B) Kaynak mevcut değil",
            "C) Başarılı istek",
            "D) Yönlendirme gerekli",
            "E) Bilgilendirici yanıt",
          ],
          correct: "B) Kaynak mevcut değil",
          explanation:
            "404, istenen kaynağın sunucuda bulunamadığını belirtir.",
        },
        {
          question:
            "ASP.NET Core'da bir Singleton servis, istek başına veriler için yanlışlıkla kullanılır. Hangi sorun ortaya çıkabilir?",
          options: [
            "A) Paylaşılan durumdan bellek sızıntıları",
            "B) Daha hızlı performans",
            "C) Yanlış yönlendirme",
            "D) Model bağlama hataları",
            "E) Ara yazılım başarısızlığı",
          ],
          correct: "A) Paylaşılan durumdan bellek sızıntıları",
          explanation:
            "Singleton, tüm istekler arasında paylaşılır ve durum sorunlarına yol açabilir.",
        },
        {
          question:
            "Bir ASP.NET Core eyleminde form verilerini bağlamak için hangi öznitelik uygundur?",
          options: [
            "A) [FromBody]",
            "B) [FromForm]",
            "C) [FromRoute]",
            "D) [FromHeader]",
            "E) [FromQuery]",
          ],
          correct: "B) [FromForm]",
          explanation: "[FromForm], form gönderimlerinden veri bağlar.",
        },
        {
          question: "Bir API HATEOAS kullanır. Bu, istemcilere ne sağlar?",
          options: [
            "A) Daha hızlı yanıt süreleri",
            "B) Gezinme için hipermedya bağlantıları",
            "C) Şifreli yükler",
            "D) Otomatik doğrulama",
            "E) Azaltılmış sunucu yükü",
          ],
          correct: "B) Gezinme için hipermedya bağlantıları",
          explanation: "HATEOAS, API'nin keşfedilebilirliğini artırır.",
        },
        {
          question:
            "Git'te, çalışma dizini ile hazırlama alanı arasındaki farkları hangi komut gösterir?",
          options: [
            "A) git log",
            "B) git status",
            "C) git diff",
            "D) git commit",
            "E) git push",
          ],
          correct: "C) git diff",
          explanation:
            "'git diff', değişikliklerin ayrıntılı karşılaştırmasını gösterir.",
        },
        {
          question:
            "ASP.NET Core'da yönlendirmeyi etkinleştirmek için hangi ara yazılım yapılandırılmalıdır?",
          options: [
            "A) app.UseAuthentication()",
            "B) app.UseRouting()",
            "C) app.UseCors()",
            "D) app.UseStaticFiles()",
            "E) app.UseHttpsRedirection()",
          ],
          correct: "B) app.UseRouting()",
          explanation:
            "app.UseRouting(), isteklerin uç noktalara yönlendirilmesini sağlar.",
        },
        {
          question:
            "Bir geliştirici, bir modelde bir değerin 1 ile 100 arasında olmasını sağlamak istiyor. Hangi veri notasyonu kullanılmalıdır?",
          options: [
            "A) [Required]",
            "B) [Range(1, 100)]",
            "C) [StringLength]",
            "D) [EmailAddress]",
            "E) [Compare]",
          ],
          correct: "B) [Range(1, 100)]",
          explanation:
            "[Range], bir değerin belirli bir aralıkta olmasını sağlar.",
        },
        {
          question:
            "Bir API'de bir kaynağı silmek için hangi HTTP metodu kullanılmalıdır?",
          options: ["A) GET", "B) POST", "C) PUT", "D) DELETE", "E) PATCH"],
          correct: "D) DELETE",
          explanation: "DELETE, kaynakları silmek için tanımlanmıştır.",
        },
        {
          question: "Git'te 'git merge', dalları birleştirirken ne yapar?",
          options: [
            "A) Yeni bir dal oluşturur",
            "B) Değişiklikleri mevcut dala birleştirir",
            "C) Kaynak dalı siler",
            "D) Commit geçmişini sıfırlar",
            "E) Commit edilmemiş değişiklikleri saklar",
          ],
          correct: "B) Değişiklikleri mevcut dala birleştirir",
          explanation:
            "'git merge', dalları birleştirerek değişiklikleri bir araya getirir.",
        },
        {
          question:
            "Bir ASP.NET Core rotası '/users/{id}', '/users/abc' ile eşleşmez. Neden?",
          options: [
            "A) Eksik sorgu parametresi",
            "B) Yanlış HTTP metodu",
            "C) Rota kısıtlaması uyuşmazlığı (örn. int bekleniyor)",
            "D) Ara yazılım yapılandırılmamış",
            "E) Geçersiz JSON yükü",
          ],
          correct: "C) Rota kısıtlaması uyuşmazlığı (örn. int bekleniyor)",
          explanation: "'id' tamsayı bekler, ancak 'abc' bir dizedir.",
        },
        {
          question:
            "ASP.NET Core'da [FromHeader] özniteliği bir eylemde ne yapar?",
          options: [
            "A) İstek gövdesinden veri bağlar",
            "B) HTTP başlıklarından veri bağlar",
            "C) Rotadan veri bağlar",
            "D) Sorgu dizelerinden veri bağlar",
            "E) Form alanlarından veri bağlar",
          ],
          correct: "B) HTTP başlıklarından veri bağlar",
          explanation: "[FromHeader], başlık verilerini parametreye bağlar.",
        },
        {
          question:
            "Bir API tasarlarken veri alışverişi için JSON neden tercih edilir?",
          options: [
            "A) XML'den daha hızlıdır",
            "B) İnsan tarafından okunabilir ve yaygın desteklenir",
            "C) İkili veriyi doğal olarak destekler",
            "D) Katı tip tanımlamayı zorlar",
            "E) Sunucu bellek kullanımını azaltır",
          ],
          correct: "B) İnsan tarafından okunabilir ve yaygın desteklenir",
          explanation: "JSON, okunabilirliği ve uyumluluğu ile öne çıkar.",
        },
        {
          question:
            "Bir .NET Core uygulaması hem Windows hem Linux'ta çalışmalıdır. Bunu hangi ASP.NET Core özelliği mümkün kılar?",
          options: [
            "A) Bağımlılık Enjeksiyonu",
            "B) Platformlar arası doğası",
            "C) Ara yazılım hattı",
            "D) Yönlendirme sistemi",
            "E) Model bağlama",
          ],
          correct: "B) Platformlar arası doğası",
          explanation:
            "ASP.NET Core, çoklu platform desteği ile tasarlanmıştır.",
        },
        {
          question: "Git'te 'git remote add origin <url>' neyi başarır?",
          options: [
            "A) Bir depoyu klonlar",
            "B) Yerel depoyu bir uzak depoya bağlar",
            "C) Değişiklikleri uzak depoya gönderir",
            "D) Yeni bir dal oluşturur",
            "E) Uzak değişiklikleri alır",
          ],
          correct: "B) Yerel depoyu bir uzak depoya bağlar",
          explanation: "Bu komut, yerel depoyu uzak bir depoya bağlar.",
        },
      ];

      const modelB = [
        {
          question:
            "TCP/IP yığınında veri aşağı doğru hareket ederken her katman ne ekler?",
          options: [
            "A) Veri gövdesi",
            "B) Başlık bilgisi",
            "C) Şifreleme anahtarı",
            "D) Rota bilgisi",
            "E) Hata kodu",
          ],
          correct: "B) Başlık bilgisi",
          explanation:
            "Kapsülleme sırasında her katman, veriye kendi başlık bilgisini ekler.",
        },
        {
          question:
            "Bir istemci, sunucudan bir web sayfası istediğinde hangi protokol kullanılır?",
          options: ["A) FTP", "B) HTTP", "C) SMTP", "D) DNS", "E) UDP"],
          correct: "B) HTTP",
          explanation:
            "HTTP, web sayfalarının istemci-sunucu arasında aktarımı için kullanılır.",
        },
        {
          question: "IPv6 adresleri kaç bit uzunluğundadır?",
          options: ["A) 32", "B) 64", "C) 128", "D) 256", "E) 16"],
          correct: "C) 128",
          explanation:
            "IPv6, 128 bitlik adreslerle daha geniş bir adres alanı sağlar.",
        },
        {
          question:
            "Bir .NET Core uygulamasını çalıştırmak için hangi komut kullanılır?",
          options: [
            "A) dotnet build",
            "B) dotnet run",
            "C) dotnet new",
            "D) dotnet restore",
            "E) dotnet publish",
          ],
          correct: "B) dotnet run",
          explanation: "'dotnet run', projeyi derler ve çalıştırır.",
        },
        {
          question:
            "Bir geliştirici, yalnızca belirli bir dosyayı bir sonraki commit için hazırlamak istiyor. Hangi Git komutunu kullanır?",
          options: [
            "A) git add .",
            "B) git commit",
            "C) git add <dosya>",
            "D) git push",
            "E) git stash",
          ],
          correct: "C) git add <dosya>",
          explanation:
            "'git add <dosya>', belirli bir dosyayı hazırlama alanına ekler.",
        },
        {
          question:
            "Uzak bir depoyu yerel makineye indirmek için hangi Git komutu kullanılır?",
          options: [
            "A) git fetch",
            "B) git pull",
            "C) git clone",
            "D) git remote add",
            "E) git push",
          ],
          correct: "C) git clone",
          explanation:
            "'git clone', bir depoyu tamamen yerel makineye kopyalar.",
        },
        {
          question:
            "Git’te birleştirme çakışmalarını çözmek için hangi komut kullanılır?",
          options: [
            "A) git merge",
            "B) git rebase",
            "C) git commit",
            "D) git resolve",
            "E) git checkout",
          ],
          correct: "A) git merge",
          explanation:
            "'git merge' sırasında çakışmalar manuel olarak çözülür ve ardından commit edilir.",
        },
        {
          question:
            "Git’te bir etiket (tag) oluşturmak için hangi komut kullanılır?",
          options: [
            "A) git tag",
            "B) git branch",
            "C) git commit",
            "D) git push",
            "E) git log",
          ],
          correct: "A) git tag",
          explanation: "'git tag', belirli bir commit’e etiket ekler.",
        },
        {
          question:
            "Bir API, yeni bir kaynak oluşturmak için hangi HTTP metodunu kullanır?",
          options: ["A) GET", "B) POST", "C) PUT", "D) DELETE", "E) PATCH"],
          correct: "B) POST",
          explanation: "POST, yeni kaynaklar oluşturmak için kullanılır.",
        },
        {
          question:
            "Bir istemci, geçersiz bir istek gönderdiğinde sunucu hangi HTTP durum kodu sınıfını döndürür?",
          options: ["A) 1xx", "B) 2xx", "C) 3xx", "D) 4xx", "E) 5xx"],
          correct: "D) 4xx",
          explanation:
            "4xx kodları, istemci hatalarını gösterir (örn. 400 Bad Request).",
        },
        {
          question:
            "ASP.NET Core’da hangi dosya, proje yapılandırma ayarlarını içerir?",
          options: [
            "A) Program.cs",
            "B) appsettings.json",
            "C) Startup.cs",
            "D) Controller.cs",
            "E) wwwroot/index.html",
          ],
          correct: "B) appsettings.json",
          explanation: "appsettings.json, yapılandırma ayarlarını saklar.",
        },
        {
          question: "ASP.NET Core’da özel bir ara yazılım nasıl eklenir?",
          options: [
            "A) Controller’a kod yazılır",
            "B) Program.cs’de Use metodu ile",
            "C) Yeni bir proje oluşturulur",
            "D) appsettings.json’a eklenir",
            "E) Otomatik olarak eklenir",
          ],
          correct: "B) Program.cs’de Use metodu ile",
          explanation: "Özel ara yazılım, Use metodu ile pipeline’a eklenir.",
        },
        {
          question:
            "ASP.NET Core’da her istek için yeni bir servis örneği oluşturulması için hangi yaşam süresi kullanılır?",
          options: [
            "A) Singleton",
            "B) Scoped",
            "C) Transient",
            "D) PerResolve",
            "E) RequestScoped",
          ],
          correct: "C) Transient",
          explanation:
            "Transient, her bağımlılık çözümlemesinde yeni bir örnek oluşturur.",
        },
        {
          question: "Bağımlılık Enjeksiyonu’nun temel prensibi nedir?",
          options: [
            "A) Kontrolün Tersine Çevrilmesi",
            "B) Hızlı Yanıt",
            "C) Veri Şifreleme",
            "D) Rota Tanımlama",
            "E) Model Bağlama",
          ],
          correct: "A) Kontrolün Tersine Çevrilmesi",
          explanation: "DI, IoC prensibine dayanır.",
        },
        {
          question: "ASP.NET Core’da rota parametrelerini nasıl tanımlarsınız?",
          options: [
            "A) [FromBody] ile",
            "B) {param} sözdizimi ile",
            "C) Sorgu dizesi ile",
            "D) Başlık ile",
            "E) Form ile",
          ],
          correct: "B) {param} sözdizimi ile",
          explanation:
            "Rota parametreleri, şablonlarda {param} ile tanımlanır.",
        },
        {
          question:
            "ASP.NET Core’da bir rota şablonunda isteğe bağlı bir parametre nasıl belirtilir?",
          options: [
            "A) :int ile",
            "B) ? ile",
            "C) * ile",
            "D) ! ile",
            "E) = ile",
          ],
          correct: "B) ? ile",
          explanation:
            "? işareti, parametrenin isteğe bağlı olduğunu belirtir.",
        },
        {
          question:
            "ASP.NET Core’da bir eylem, rota verilerinden parametre nasıl alır?",
          options: [
            "A) [FromBody]",
            "B) [FromRoute]",
            "C) [FromQuery]",
            "D) [FromHeader]",
            "E) [FromForm]",
          ],
          correct: "B) [FromRoute]",
          explanation: "[FromRoute], rota verilerinden parametre bağlar.",
        },
        {
          question:
            "Bir controller, istemciye JSON verisi döndürmek için hangi IActionResult metodunu kullanır?",
          options: [
            "A) Ok()",
            "B) Json()",
            "C) File()",
            "D) Content()",
            "E) StatusCode()",
          ],
          correct: "B) Json()",
          explanation: "Json(), JSON biçiminde veri döndürür.",
        },
        {
          question: "ASP.NET Core’da istek başlıklarına nasıl erişilir?",
          options: [
            "A) HttpContext.Request.Headers",
            "B) ModelState",
            "C) Response.Headers",
            "D) IActionResult",
            "E) Request.Body",
          ],
          correct: "A) HttpContext.Request.Headers",
          explanation: "HttpContext.Request.Headers, başlıklara erişim sağlar.",
        },
        {
          question:
            "Model bağlama sırasında Content-Type başlığı neden önemlidir?",
          options: [
            "A) Hızlı yanıt için",
            "B) Doğru biçimlendiriciyi seçmek için",
            "C) Şifreleme için",
            "D) Rota eşleşmesi için",
            "E) Durum kodu için",
          ],
          correct: "B) Doğru biçimlendiriciyi seçmek için",
          explanation:
            "Content-Type, model bağlama için doğru biçimlendiriciyi belirler.",
        },
        {
          question:
            "Bir modelde bir alanın zorunlu olduğunu nasıl belirtirsiniz?",
          options: [
            "A) [Required]",
            "B) [StringLength]",
            "C) [Range]",
            "D) [EmailAddress]",
            "E) [Compare]",
          ],
          correct: "A) [Required]",
          explanation: "[Required], bir alanın zorunlu olduğunu belirtir.",
        },
        {
          question:
            "ASP.NET Core’da doğrulama hatalarını kontrol etmek için hangi özellik kullanılır?",
          options: [
            "A) HttpContext",
            "B) ModelState.IsValid",
            "C) Request.Headers",
            "D) Response.StatusCode",
            "E) IActionResult",
          ],
          correct: "B) ModelState.IsValid",
          explanation: "ModelState.IsValid, doğrulama durumunu kontrol eder.",
        },
        {
          question: "API tasarımında URI’lar için en iyi uygulama nedir?",
          options: [
            "A) Fiiller kullanmak",
            "B) İsimler ve hiyerarşiler kullanmak",
            "C) Rastgele desenler",
            "D) Sorgu parametrelerinden kaçınmak",
            "E) Kısa URI’lar",
          ],
          correct: "B) İsimler ve hiyerarşiler kullanmak",
          explanation:
            "URI’lar, kaynak isimleri ve hiyerarşilerle yapılandırılır.",
        },
        {
          question: "Bir API, kaynakları sıralamak için ne kullanır?",
          options: [
            "A) Rota parametreleri",
            "B) Sorgu parametreleri",
            "C) Başlıklar",
            "D) Gövde",
            "E) Durum kodları",
          ],
          correct: "B) Sorgu parametreleri",
          explanation:
            "Sorgu parametreleri, sıralama ve filtreleme için kullanılır.",
        },
        {
          question: "HTTP’de idempotent bir metot nedir?",
          options: ["A) POST", "B) GET", "C) PATCH", "D) OPTIONS", "E) HEAD"],
          correct: "B) GET",
          explanation:
            "GET, tekrarlanan isteklerde aynı sonucu döndürür (idempotent).",
        },
        {
          question: "Git’te bir dalı silmek için hangi komut kullanılır?",
          options: [
            "A) git branch -d",
            "B) git checkout",
            "C) git merge",
            "D) git reset",
            "E) git stash",
          ],
          correct: "A) git branch -d",
          explanation: "'git branch -d', bir dalı siler.",
        },
        {
          question:
            "ASP.NET Core’da hangi dosya varsayılan olarak statik dosyaları sunar?",
          options: [
            "A) wwwroot",
            "B) Program.cs",
            "C) appsettings.json",
            "D) Startup.cs",
            "E) Controller.cs",
          ],
          correct: "A) wwwroot",
          explanation: "wwwroot, statik dosyaların varsayılan dizinidir.",
        },
        {
          question:
            "Bir API, istemciye yönlendirme gerektiğinde hangi HTTP durum kodunu döndürür?",
          options: ["A) 200", "B) 301", "C) 404", "D) 500", "E) 201"],
          correct: "B) 301",
          explanation: "301 Moved Permanently, yönlendirme için kullanılır.",
        },
        {
          question:
            "ASP.NET Core’da DI konteynerine bir servis nasıl kaydedilir?",
          options: [
            "A) AddSingleton ile",
            "B) UseMiddleware ile",
            "C) Json() ile",
            "D) FromBody ile",
            "E) Route ile",
          ],
          correct: "A) AddSingleton ile",
          explanation: "AddSingleton, servisleri DI konteynerine kaydeder.",
        },
        {
          question:
            "Bir ASP.NET Core rotasında hata ayıklama için ilk adım nedir?",
          options: [
            "A) Veritabanını kontrol et",
            "B) HTTP metodunu doğrula",
            "C) IP adresini kontrol et",
            "D) Belleği artır",
            "E) JSON’u sıkıştır",
          ],
          correct: "B) HTTP metodunu doğrula",
          explanation: "Hatalı HTTP metodu, rota eşleşmesini engelleyebilir.",
        },
        {
          question:
            "ASP.NET Core’da bir eylem, istemciye düz metin döndürmek için hangi metodu kullanır?",
          options: [
            "A) Ok()",
            "B) Json()",
            "C) Content()",
            "D) File()",
            "E) StatusCode()",
          ],
          correct: "C) Content()",
          explanation: "Content(), düz metin veya özel içerik döndürür.",
        },
        {
          question: "Bir modelde özel doğrulama mantığı nasıl uygulanır?",
          options: [
            "A) Controller’da",
            "B) IValidatableObject ile",
            "C) Middleware ile",
            "D) Program.cs’de",
            "E) JSON’da",
          ],
          correct: "B) IValidatableObject ile",
          explanation: "IValidatableObject, özel doğrulama için kullanılır.",
        },
        {
          question: "API tasarımında HATEOAS neyi ifade eder?",
          options: [
            "A) Hızlı yanıt",
            "B) Hipermedya bağlantıları",
            "C) Şifreleme",
            "D) Sorgu parametreleri",
            "E) Durum kodları",
          ],
          correct: "B) Hipermedya bağlantıları",
          explanation: "HATEOAS, gezinme için hipermedya bağlantıları sağlar.",
        },
        {
          question:
            "Git’te commit geçmişini görmek için hangi komut kullanılır?",
          options: [
            "A) git status",
            "B) git log",
            "C) git diff",
            "D) git commit",
            "E) git push",
          ],
          correct: "B) git log",
          explanation: "'git log', commit geçmişini listeler.",
        },
        {
          question:
            "ASP.NET Core’da bir istemciye 201 durum kodu döndürmek için hangi metot kullanılır?",
          options: [
            "A) Ok()",
            "B) CreatedAtAction()",
            "C) Json()",
            "D) File()",
            "E) BadRequest()",
          ],
          correct: "B) CreatedAtAction()",
          explanation: "CreatedAtAction(), 201 Created durumunu döndürür.",
        },
        {
          question: "Bir API, filtreleme için hangi yapıyı kullanır?",
          options: [
            "A) Rota parametreleri",
            "B) Sorgu parametreleri",
            "C) Başlıklar",
            "D) Gövde",
            "E) Durum kodları",
          ],
          correct: "B) Sorgu parametreleri",
          explanation: "Sorgu parametreleri, filtreleme için idealdir.",
        },
        {
          question: "ASP.NET Core’da hangi ara yazılım CORS’u etkinleştirir?",
          options: [
            "A) app.UseRouting()",
            "B) app.UseCors()",
            "C) app.UseAuthentication()",
            "D) app.UseStaticFiles()",
            "E) app.UseHttpsRedirection()",
          ],
          correct: "B) app.UseCors()",
          explanation:
            "app.UseCors(), çapraz kaynak paylaşımını etkinleştirir.",
        },
      ];
      const modelC = [
        {
          question:
            "TCP/IP yığınında, istemci-sunucu modelinde bir istemcinin belirli bir hizmeti hedeflemesini sağlayan katman hangisidir ve bu nasıl başarılır?",
          options: [
            "A) Ağ Katmanı - IP adresleri ile",
            "B) Taşıma Katmanı - Port numaraları ile",
            "C) Uygulama Katmanı - HTTP başlıkları ile",
            "D) Bağlantı Katmanı - MAC adresleri ile",
            "E) Fiziksel Katman - Kablo türü ile",
          ],
          correct: "B) Taşıma Katmanı - Port numaraları ile",
          explanation:
            "Taşıma Katmanı, TCP/IP yığınında port numaraları kullanarak bir istemcinin belirli bir hizmeti (örneğin, HTTP için 80) hedeflemesini sağlar. IP adresi cihazı tanımlar, ancak port numaraları aynı cihazda çalışan farklı hizmetleri ayırt eder.",
        },
        {
          question:
            "HTTP'nin durumsuz doğası nedeniyle, bir istemci ile sunucu arasında oturum bilgisini sürdürmek için genellikle ne kullanılır?",
          options: [
            "A) IP adresleri",
            "B) Çerezler (Cookies)",
            "C) TCP bağlantıları",
            "D) DNS kayıtları",
            "E) Port numaraları",
          ],
          correct: "B) Çerezler (Cookies)",
          explanation:
            "HTTP durumsuz bir protokoldür, yani her istek bağımsızdır. Çerezler, istemci tarafında saklanan ve sunucuya geri gönderilen küçük veri parçalarıdır; oturum bilgisini sürdürmek için yaygın olarak kullanılır.",
        },
        {
          question:
            "Bir C# socket istemcisinde, sunucuya bağlanmadan önce hangi iki bilgi gereklidir?",
          options: [
            "A) IP adresi ve port numarası",
            "B) MAC adresi ve protokol türü",
            "C) HTTP yöntemi ve başlıkları",
            "D) DNS adı ve çerezler",
            "E) Kullanıcı adı ve parola",
          ],
          correct: "A) IP adresi ve port numarası",
          explanation:
            "Bir C# socket istemcisi, sunucuya bağlanmak için sunucunun IP adresini (konumu belirlemek için) ve port numarasını (hizmeti tanımlamak için) bilmelidir. Bu, ağ iletişiminin temel bir gereksinimidir.",
        },
        {
          question:
            "Git'te birleştirme çakışması (merge conflict) hangi durumda ortaya çıkar ve nasıl çözülür?",
          options: [
            "A) Aynı dosyada aynı satırlarda çakışan değişiklikler olduğunda - Manuel düzenleme ile",
            "B) Farklı dallarda farklı dosyalar değiştirildiğinde - Otomatik birleştirme ile",
            "C) Uzak depo ile yerel depo senkronize olmadığında - Git pull ile",
            "D) Bir dosya silindiğinde - Git rm ile",
            "E) Commit mesajları çakıştığında - Yeni mesajla commit ile",
          ],
          correct:
            "A) Aynı dosyada aynı satırlarda çakışan değişiklikler olduğunda - Manuel düzenleme ile",
          explanation:
            "Birleştirme çakışması, farklı dallarda aynı dosyanın aynı satırlarında çakışan değişiklikler yapıldığında oluşur. Çözüm, çakışan dosyaları manuel olarak düzenleyip ardından 'git add' ve 'git commit' ile tamamlanır.",
        },
        {
          question:
            "Merkezi Sürüm Kontrol Sistemleri (MSKS) ile Dağıtık Sürüm Kontrol Sistemleri (DSKS) arasındaki en büyük farklardan biri nedir?",
          options: [
            "A) MSKS daha hızlıdır çünkü yerel işlemler destekler",
            "B) DSKS tek bir merkezi sunucuya bağımlıdır",
            "C) MSKS'de her geliştirici tam sürüm geçmişine sahiptir",
            "D) DSKS'de her geliştirici yerel bir depo ile çalışır",
            "E) MSKS dallanma ve birleştirmeyi desteklemez",
          ],
          correct: "D) DSKS'de her geliştirici yerel bir depo ile çalışır",
          explanation:
            "DSKS (örneğin, Git), her geliştiricinin tam sürüm geçmişine sahip yerel bir depo ile çalışmasını sağlar, bu da merkezi bir sunucuya bağımlılığı ortadan kaldırır. MSKS ise tek bir merkezi sunucuya dayanır.",
        },
        {
          question:
            "Git'te 'git add .' ile 'git add -A' arasındaki fark nedir?",
          options: [
            "A) 'git add .' tüm dosyaları, 'git add -A' sadece değiştirilenleri hazırlar",
            "B) 'git add .' mevcut dizindeki değişiklikleri, 'git add -A' tüm depodaki değişiklikleri hazırlar",
            "C) 'git add .' silmeleri hariç tutar, 'git add -A' silmeleri içerir",
            "D) 'git add .' yalnızca yeni dosyaları, 'git add -A' yalnızca değiştirilenleri hazırlar",
            "E) İkisi arasında fark yoktur",
          ],
          correct:
            "B) 'git add .' mevcut dizindeki değişiklikleri, 'git add -A' tüm depodaki değişiklikleri hazırlar",
          explanation:
            "'git add .' mevcut dizin ve alt dizinlerdeki değişiklikleri hazırlar, ancak başka bir dizindeki değişiklikleri kapsamaz. 'git add -A' ise tüm depodaki değişiklikleri (silme dahil) hazırlar.",
        },
        {
          question:
            "Bir Git commit mesajında 'feat:' önekini kullanmanın amacı nedir ve hangi durumda tercih edilir?",
          options: [
            "A) Bir hatayı düzelttiğini belirtmek için - Hata düzeltme commit'lerinde",
            "B) Yeni bir özellik eklendiğini belirtmek için - Özellik geliştirme commit'lerinde",
            "C) Kod yapısını iyileştirdiğini belirtmek için - Yeniden düzenleme commit'lerinde",
            "D) Uzak depoya gönderildiğini belirtmek için - Push işlemlerinde",
            "E) Çakışmayı çözdüğünü belirtmek için - Merge commit'lerinde",
          ],
          correct:
            "B) Yeni bir özellik eklendiğini belirtmek için - Özellik geliştirme commit'lerinde",
          explanation:
            "'feat:' öneği, yeni bir özellik eklendiğini belirtir ve genellikle özellik geliştirme commit'lerinde kullanılır. Bu, commit mesajlarının türünü ve amacını açıkça ifade etmek için bir standarttır.",
        },
        {
          question:
            "'git log --oneline' komutunun çıktısı ile 'git log -p' komutunun çıktısı arasındaki temel fark nedir?",
          options: [
            "A) '--oneline' yalnızca yazar adını, '-p' commit mesajını gösterir",
            "B) '--oneline' tek satırlık özet, '-p' her commit'in farklarını gösterir",
            "C) '--oneline' dalları listeler, '-p' geçmişteki çakışmaları gösterir",
            "D) '--oneline' yalnızca son commit'i, '-p' tüm commit'leri gösterir",
            "E) '--oneline' commit hash'ini gizler, '-p' hash'i detaylandırır",
          ],
          correct:
            "B) '--oneline' tek satırlık özet, '-p' her commit'in farklarını gösterir",
          explanation:
            "'git log --oneline' her commit'i tek satırda özetler (hash ve mesaj), 'git log -p' ise her commit'in detaylı farklarını (değişikliklerini) gösterir.",
        },
        {
          question:
            "'.gitignore' dosyasında '*.log' yazıp ardından '!error.log' eklemek ne anlama gelir?",
          options: [
            "A) Tüm log dosyalarını yoksayar, ancak error.log'u hariç tutar",
            "B) Yalnızca error.log'u yoksayar, diğer log dosyalarını izler",
            "C) Tüm log dosyalarını ve error.log'u yoksayar",
            "D) error.log'u izler, diğer log dosyalarını yoksayar",
            "E) Hiçbir dosyayı yoksaymaz, yalnızca bir hata mesajı oluşturur",
          ],
          correct: "D) error.log'u izler, diğer log dosyalarını yoksayar",
          explanation:
            "'*.log' tüm log dosyalarını yoksayar, ancak '!error.log' bu kuralı olumsuzlayarak yalnızca 'error.log' dosyasının izlenmesini sağlar.",
        },
        {
          question: "'git checkout -b feature-x main' komutu ne yapar?",
          options: [
            "A) 'feature-x' dalını siler ve 'main'e geçer",
            "B) 'main' dalından 'feature-x' dalını oluşturur ve ona geçer",
            "C) 'feature-x' dalını 'main' ile birleştirir",
            "D) 'feature-x' dalını listeler ve 'main'e geçer",
            "E) 'main' dalını 'feature-x' ile yeniden adlandırır",
          ],
          correct:
            "B) 'main' dalından 'feature-x' dalını oluşturur ve ona geçer",
          explanation:
            "'git checkout -b feature-x main', 'main' dalından 'feature-x' adında yeni bir dal oluşturur ve çalışma dizinini bu yeni dala geçirir.",
        },
        {
          question:
            "HTTPS'nin TCP/IP yığınındaki hangi katmanla ilişkilendirilen bir güvenlik özelliği vardır?",
          options: [
            "A) Ağ Katmanı - IPsec",
            "B) Taşıma Katmanı - SSL/TLS",
            "C) Uygulama Katmanı - HTTP",
            "D) Bağlantı Katmanı - Ethernet",
            "E) Fiziksel Katman - Kablo şifrelemesi",
          ],
          correct: "B) Taşıma Katmanı - SSL/TLS",
          explanation:
            "HTTPS, SSL/TLS kullanarak şifreleme sağlar ve bu, TCP/IP yığınında Taşıma Katmanı ile ilişkilidir. HTTP ise Uygulama Katmanında çalışır, ancak güvenliği SSL/TLS sağlar.",
        },
        {
          question: "'git push origin --tags' komutunun amacı nedir?",
          options: [
            "A) Tüm dalları uzak depoya gönderir",
            "B) Yalnızca etiketleri uzak depoya gönderir",
            "C) Tüm etiketleri ve commit'leri uzak depoya gönderir",
            "D) Etiketleri siler ve uzak depoyu günceller",
            "E) Yerel etiketleri listeler",
          ],
          correct: "C) Tüm etiketleri ve commit'leri uzak depoya gönderir",
          explanation:
            "'git push origin --tags', yerel depodaki tüm etiketleri (ve ilgili commit'leri) uzak depoya gönderir. Etiketler otomatik olarak gönderilmez, bu nedenle bu komut gereklidir.",
        },
        {
          question:
            "Git'te 'git stash pop' ile 'git stash apply' arasındaki fark nedir?",
          options: [
            "A) 'pop' saklamayı siler, 'apply' saklamayı korur",
            "B) 'pop' yalnızca hazırlanmış değişiklikleri, 'apply' tüm değişiklikleri uygular",
            "C) 'pop' yeni bir dal oluşturur, 'apply' mevcut dala uygular",
            "D) 'pop' saklamayı korur, 'apply' saklamayı siler",
            "E) 'pop' geçmişteki commit'leri, 'apply' yalnızca farkları uygular",
          ],
          correct: "A) 'pop' saklamayı siler, 'apply' saklamayı korur",
          explanation:
            "'git stash pop', saklanmış değişiklikleri uygular ve saklama listesinden kaldırır; 'git stash apply' ise değişiklikleri uygular ama saklamayı listede tutar.",
        },
        {
          question:
            "Özellik Dalı İş Akışı'nda, 'main' dalını güncel tutmak için hangi komut dizisi sıkça kullanılır?",
          options: [
            "A) git fetch && git merge",
            "B) git pull origin main",
            "C) git push origin main",
            "D) git branch -d main",
            "E) git stash && git commit",
          ],
          correct: "B) git pull origin main",
          explanation:
            "'git pull origin main', uzak 'main' dalındaki en son değişiklikleri yerel 'main' dalına çeker ve birleştirir, Özellik Dalı İş Akışı'nda ana dalı güncel tutmak için yaygın bir yöntemdir.",
        },
        {
          question:
            "Bir .NET Core uygulamasında, 'dotnet restore' komutunun temel amacı nedir?",
          options: [
            "A) Projeyi derler",
            "B) Bağımlılıkları indirir ve yükler",
            "C) Uygulamayı çalıştırır",
            "D) Yeni bir proje oluşturur",
            "E) Yayın için paketler",
          ],
          correct: "B) Bağımlılıkları indirir ve yükler",
          explanation:
            "'dotnet restore', proje dosyasındaki belirtilen bağımlılıkları (örneğin, NuGet paketleri) indirir ve yükler, uygulamanın çalışması için gerekli ortamı hazırlar.",
        },
        {
          question:
            "Git'te 'git fetch' ile 'git pull' arasındaki temel fark nedir?",
          options: [
            "A) 'fetch' yerel dalı günceller, 'pull' yalnızca uzak değişiklikleri getirir",
            "B) 'fetch' uzak değişiklikleri getirir ama birleştirmez, 'pull' getirir ve birleştirir",
            "C) 'fetch' yalnızca dalları, 'pull' yalnızca etiketleri getirir",
            "D) 'fetch' commit'leri siler, 'pull' commit'leri korur",
            "E) 'fetch' yerel depoyu temizler, 'pull' uzak depoyu günceller",
          ],
          correct:
            "B) 'fetch' uzak değişiklikleri getirir ama birleştirmez, 'pull' getirir ve birleştirir",
          explanation:
            "'git fetch', uzak depodan değişiklikleri getirir ama yerel dal ile birleştirmez; 'git pull' ise bu değişiklikleri getirir ve otomatik olarak birleştirir.",
        },
        {
          question:
            "HTTP'de 'POST' ve 'PUT' metodları arasındaki temel fark nedir?",
          options: [
            "A) 'POST' veri alır, 'PUT' veri gönderir",
            "B) 'POST' yeni kaynak oluşturur, 'PUT' mevcut kaynağı günceller",
            "C) 'POST' idempotenttir, 'PUT' değildir",
            "D) 'POST' yalnızca istemciye, 'PUT' yalnızca sunucuya uygulanır",
            "E) 'POST' başlık gerektirir, 'PUT' gerektirmez",
          ],
          correct:
            "B) 'POST' yeni kaynak oluşturur, 'PUT' mevcut kaynağı günceller",
          explanation:
            "'POST', genellikle yeni bir kaynak oluşturmak için kullanılırken, 'PUT' mevcut bir kaynağı güncellemek için kullanılır. 'PUT' idempotenttir, 'POST' ise değildir.",
        },
        {
          question:
            "GitHub'da Çatallama ve Çekme İsteği modelinde, orijinal depodan güncellemeleri almak için hangi komut kullanılır?",
          options: [
            "A) git push origin main",
            "B) git pull upstream main",
            "C) git fetch origin feature",
            "D) git merge origin main",
            "E) git clone upstream",
          ],
          correct: "B) git pull upstream main",
          explanation:
            "Çatallama modelinde, orijinal depo genellikle 'upstream' olarak eklenir. 'git pull upstream main', orijinal deponun 'main' dalındaki güncellemeleri yerel depoya çeker ve birleştirir.",
        },
        {
          question:
            "Bir C# programında 'Console.WriteLine' ile 'Console.Write' arasındaki fark nedir?",
          options: [
            "A) 'WriteLine' dosyaya yazar, 'Write' konsola yazar",
            "B) 'WriteLine' satır sonu ekler, 'Write' eklemez",
            "C) 'WriteLine' yalnızca sayıları, 'Write' yalnızca metni yazdırır",
            "D) 'WriteLine' hata mesajları için, 'Write' normal çıktı için kullanılır",
            "E) 'WriteLine' daha hızlıdır, 'Write' daha yavaştır",
          ],
          correct: "B) 'WriteLine' satır sonu ekler, 'Write' eklemez",
          explanation:
            "'Console.WriteLine', metni konsola yazdırır ve ardından bir satır sonu ekler; 'Console.Write' ise satır sonu eklemeden yazdırır.",
        },
        {
          question:
            "Git'te birleştirme çakışmasını çözdükten sonra hangi adımlar izlenir?",
          options: [
            "A) git merge --continue, git push",
            "B) git add <dosya>, git commit",
            "C) git fetch, git pull",
            "D) git stash, git apply",
            "E) git branch -d, git log",
          ],
          correct: "B) git add <dosya>, git commit",
          explanation:
            "Birleştirme çakışması çözüldükten sonra, çakışan dosyalar 'git add' ile hazırlanır ve ardından 'git commit' ile birleştirme tamamlanır.",
        },
        {
          question:
            "Bir HTTP isteğinin temel bileşenlerinden biri olan 'İstek Satırı' hangi bilgileri içerir?",
          options: [
            "A) Yalnızca HTTP metodunu",
            "B) HTTP metodu, URI ve HTTP sürümünü",
            "C) Yalnızca URI ve başlıkları",
            "D) HTTP sürümünü ve gövde verilerini",
            "E) Başlıkları ve durum kodunu",
          ],
          correct: "B) HTTP metodu, URI ve HTTP sürümünü",
          explanation:
            "HTTP isteğinin 'İstek Satırı', istemcinin talebini tanımlayan ilk satırdır ve üç ana bileşenden oluşur: HTTP metodu (örneğin, GET, POST), URI (istenen kaynağın konumu) ve HTTP sürümü (örneğin, HTTP/1.1). Bu, isteğin temel yapısını oluşturur.",
        },
        {
          question: "HTTP yanıtında 'Durum Kodu' neyi ifade eder?",
          options: [
            "A) Sunucunun kimlik bilgilerini",
            "B) İsteğin sonucunu gösteren üç basamaklı bir sayıyı",
            "C) Yanıt gövdesinin boyutunu",
            "D) İstekteki başlıkların sayısını",
            "E) Kullanılan HTTP metodunu",
          ],
          correct: "B) İsteğin sonucunu gösteren üç basamaklı bir sayıyı",
          explanation:
            "HTTP yanıtındaki 'Durum Kodu', istemcinin isteğinin sonucunu ifade eden üç basamaklı bir tamsayıdır (örneğin, 200 OK, 404 Not Found). Bu kod, isteğin başarılı olup olmadığını veya bir hata olup olmadığını hızlıca bildirir.",
        },
        {
          question: "HTTP 'GET' metodunun temel özelliklerinden biri nedir?",
          options: [
            "A) Sunucuda yan etkilere neden olur",
            "B) İdempotent değildir",
            "C) Salt okunur bir işlem yapar ve güvenlidir",
            "D) İstek gövdesi gerektirir",
            "E) Yeni kaynaklar oluşturur",
          ],
          correct: "C) Salt okunur bir işlem yapar ve güvenlidir",
          explanation:
            "GET metodu, bir kaynağın temsilini almak için kullanılır ve salt okunurdur, yani sunucu üzerinde yan etkilere neden olmaz (güvenlidir). Aynı zamanda idempotenttir, yani aynı isteği birden fazla kez yapmak aynı sonucu üretir.",
        },
        {
          question: "HTTP 'POST' metodu genellikle ne için kullanılır?",
          options: [
            "A) Bir kaynağı silmek",
            "B) Bir kaynağı yalnızca almak",
            "C) Sunucuda yeni bir kaynak oluşturmak",
            "D) Mevcut bir kaynağı kısmi olarak güncellemek",
            "E) Sunucu yeteneklerini sorgulamak",
          ],
          correct: "C) Sunucuda yeni bir kaynak oluşturmak",
          explanation:
            "POST metodu, sunucuya veri göndererek genellikle yeni bir kaynak oluşturmak için kullanılır (örneğin, bir sipariş kaydı). İdempotent değildir ve sunucu durumunda değişikliklere yol açabilir.",
        },
        {
          question: "HTTP durum kodlarından '404 Not Found' ne anlama gelir?",
          options: [
            "A) İstek başarıyla tamamlandı",
            "B) Sunucu isteği işleyemedi",
            "C) İstenen kaynak bulunamadı",
            "D) İstemci kimlik doğrulaması gerekiyor",
            "E) Kaynak kalıcı olarak taşındı",
          ],
          correct: "C) İstenen kaynak bulunamadı",
          explanation:
            "404 Not Found durum kodu, sunucunun istemcinin talep ettiği URI ile eşleşen bir kaynak bulamadığını gösterir. Bu, istemci tarafı bir hata olarak sınıflandırılır (4xx).",
        },
        {
          question: "ASP.NET Core'un temel avantajlarından biri nedir?",
          options: [
            "A) Yalnızca Windows üzerinde çalışır",
            "B) Platformlar arası bir framework olması",
            "C) Yavaş performansı",
            "D) Kapalı kaynaklı olması",
            "E) Bağımlılık enjeksiyonunu desteklememesi",
          ],
          correct: "B) Platformlar arası bir framework olması",
          explanation:
            "ASP.NET Core, Windows, macOS ve Linux gibi farklı platformlarda çalışabilen platformlar arası bir framework’tür. Bu, geliştiricilere esneklik sağlar ve modern web geliştirme için önemli bir avantajdır.",
        },
        {
          question: "ASP.NET Core'da 'Middleware' neyi ifade eder?",
          options: [
            "A) Veritabanı bağlantı katmanını",
            "B) HTTP isteklerini ve yanıtlarını işleyen bir bileşeni",
            "C) Kullanıcı arayüzü oluşturma aracını",
            "D) Yalnızca statik dosyaları sunan bir modülü",
            "E) Sunucu donanımını kontrol eden bir yazılımı",
          ],
          correct: "B) HTTP isteklerini ve yanıtlarını işleyen bir bileşeni",
          explanation:
            "ASP.NET Core'da Middleware, HTTP isteklerini ve yanıtlarını işlemek için bir uygulama pipeline’ına eklenen yazılımdır. Pipeline boyunca isteği işleyebilir veya bir sonraki middleware’e iletebilir.",
        },
        {
          question: "HTTP başlıklarından 'Content-Type' hangi bilgiyi sağlar?",
          options: [
            "A) İsteğin tarih ve saatini",
            "B) Gövdenin medya türünü",
            "C) Sunucunun kimliğini",
            "D) Önbellekleme süresini",
            "E) İstemcinin IP adresini",
          ],
          correct: "B) Gövdenin medya türünü",
          explanation:
            "Content-Type başlığı, HTTP isteği veya yanıtındaki gövdenin medya türünü belirtir (örneğin, application/json, text/html). Bu, içeriğin nasıl yorumlanacağını alıcıya bildirir.",
        },
        {
          question:
            "ASP.NET Core'da bir Web API projesi oluştururken varsayılan olarak hangi dosya uygulamanın giriş noktasını tanımlar?",
          options: [
            "A) appsettings.json",
            "B) Program.cs",
            "C) WeatherForecastController.cs",
            "D) launchSettings.json",
            "E) WebApp.csproj",
          ],
          correct: "B) Program.cs",
          explanation:
            "Program.cs dosyası, ASP.NET Core uygulamasının giriş noktasıdır. Hizmetleri ve middleware pipeline’ını yapılandırır ve uygulamayı başlatır.",
        },
        {
          question:
            "HTTP metodlarından 'PATCH' ile 'PUT' arasındaki temel fark nedir?",
          options: [
            "A) PATCH bir kaynağı siler, PUT ise oluşturur",
            "B) PATCH bir kaynakta kısmi değişiklikler yapar, PUT ise tüm kaynağı günceller",
            "C) PATCH idempotenttir, PUT ise değildir",
            "D) PATCH yalnızca veri almak için kullanılır, PUT ise veri gönderir",
            "E) PATCH gövde gerektirmez, PUT ise gerektirir",
          ],
          correct:
            "B) PATCH bir kaynakta kısmi değişiklikler yapar, PUT ise tüm kaynağı günceller",
          explanation:
            "PATCH metodu, bir kaynakta yalnızca belirtilen kısımları güncellemek için kullanılırken, PUT metodu tüm kaynağı değiştirir veya yeni bir kaynak oluşturur. PATCH genellikle daha verimlidir çünkü sadece değişen verileri gönderir.",
        },
      ];
      const modelD = [
        {
          question: "İstemci-Sunucu Modeli’nde istemcinin temel rolü nedir?",
          options: [
            "A) İstekleri dinler ve yanıtlar gönderir",
            "B) Bir sunucudan hizmet veya kaynak ister",
            "C) Veritabanı sorgularını işler ve sonuçları saklar",
            "D) Ağ protokollerini tanımlayarak iletişimi düzenler",
            "E) Yanıtları şifreleyerek güvenliği sağlar",
          ],
          correct: "B) Bir sunucudan hizmet veya kaynak ister",
          explanation:
            "İstemci-Sunucu Modeli’nde istemci, bir sunucudan hizmet veya kaynak talep eden bir uygulama veya sistemdir. Örneğin, bir web tarayıcısı (istemci) bir web sunucusundan web sayfası içeriği isteğinde bulunur. Sunucu ise bu isteklere yanıt verir. Bu temel ayrım, Week 1 materyalinde (sayfa 2) istemci-sunucu mimarisinin tanımı ve örnekleriyle açıkça belirtilmiştir.",
        },
        {
          question: "HTTP’nin durumsuz (stateless) doğası ne anlama gelir?",
          options: [
            "A) Sunucu, istemci istekleri arasında oturum bilgisi saklar",
            "B) Her istek, önceki isteklerden bağımsız olarak işlenir",
            "C) İstemci, sunucuya yalnızca bir kez istek gönderebilir",
            "D) Sunucu, istemcinin kimliğini otomatik olarak tanır",
            "E) İstekler sırayla işlenmez",
          ],
          correct: "B) Her istek, önceki isteklerden bağımsız olarak işlenir",
          explanation:
            "HTTP’nin durumsuzluğu, her istemci isteğinin sunucu tarafından önceki isteklerden bağımsız bir işlem olarak ele alındığını ifade eder. Sunucu, oturum bilgisi tutmaz; her istek tüm gerekli bilgileri içermelidir. Bu, Week 1 materyalinde (sayfa 5) HTTP’nin durumsuzluğu başlığı altında detaylıca açıklanmıştır.",
        },
        {
          question: "TCP/IP yığınında Uygulama Katmanı’nın temel işlevi nedir?",
          options: [
            "A) Veri paketlerinin yönlendirilmesini sağlar",
            "B) Fiziksel adresleme ve veri çerçevelemesi yapar",
            "C) Kullanıcı uygulamalarına ağ hizmetleri sunar",
            "D) Veri akışını sıralı ve güvenilir hale getirir",
            "E) IP adreslerini fiziksel adreslere çevirir",
          ],
          correct: "C) Kullanıcı uygulamalarına ağ hizmetleri sunar",
          explanation:
            "TCP/IP yığınında Uygulama Katmanı, en üst katmandır ve uygulamalarla doğrudan etkileşim kurarak ağ hizmetleri sağlar. HTTP, SMTP gibi protokoller bu katmanda çalışır. Bu, Week 1 materyalinde (sayfa 6) TCP/IP yığınının katmanları açıklanırken belirtilmiştir.",
        },
        {
          question: "İstek-Yanıt Döngüsü’nde sunucunun ikinci adımı nedir?",
          options: [
            "A) İstemciye yanıt gönderir",
            "B) İsteği alır ve işler",
            "C) İstemciden istek bekler",
            "D) Veriyi şifreler",
            "E) İstek için bir protokol tanımlar",
          ],
          correct: "B) İsteği alır ve işler",
          explanation:
            "İstek-Yanıt Döngüsü’nde ikinci adım, sunucunun istemciden gelen isteği alması ve işlemesidir. Bu, veritabanından veri alma veya mantık yürütme gibi işlemleri içerebilir. Week 1 materyalinde (sayfa 3) bu döngü adım adım açıklanmıştır.",
        },
        {
          question:
            "Aşağıdakilerden hangisi istemci-sunucu etkileşimine bir örnektir?",
          options: [
            "A) Bir web tarayıcısının bir web sayfasını istemesi",
            "B) Bir sunucunun istemciye kendiliğinden veri göndermesi",
            "C) İki sunucunun birbirine veri aktarması",
            "D) Bir istemcinin ağ protokollerini tanımlaması",
            "E) Bir veritabanının kendi kendine güncellenmesi",
          ],
          correct: "A) Bir web tarayıcısının bir web sayfasını istemesi",
          explanation:
            "İstemci-sunucu etkileşiminde istemci bir istek başlatır ve sunucu yanıt verir. Web tarayıcısının bir web sayfasını istemesi, bu modelin günlük bir örneğidir ve Week 1 materyalinde (sayfa 2) ‘Web’de Gezinme’ örneğiyle açıklanmıştır.",
        },
        {
          question: "HTTP metotlarından ‘GET’ hangi amaçla kullanılır?",
          options: [
            "A) Bir kaynağı güncellemek için",
            "B) Bir sunucudan veri almak için",
            "C) Bir kaynağı silmek için",
            "D) Bir sunucuya veri göndermek için",
            "E) Bir kaynağa kısmi değişiklik yapmak için",
          ],
          correct: "B) Bir sunucudan veri almak için",
          explanation:
            "‘GET’ metodu, bir sunucudan veri almak için kullanılır ve salt okunur işlemler için uygundur. Güvenli ve idempotenttir. Bu, Week 1 materyalinde (sayfa 10) HTTP metotları bölümünde açıklanmıştır.",
        },
        {
          question: "Ağ protokolleri arasında TCP’nin temel farkı nedir?",
          options: [
            "A) Hızlı ama güvenilir değildir",
            "B) Bağlantı odaklı ve güvenilirdir",
            "C) Fiziksel iletimi yönetir",
            "D) Yönlendirme işlemlerini yapar",
            "E) Şifreleme sağlar",
          ],
          correct: "B) Bağlantı odaklı ve güvenilirdir",
          explanation:
            "TCP (İletim Kontrol Protokolü), Taşıma Katmanı’nda çalışır ve verilerin sıralı, hatasız teslimini sağlar. Bağlantı odaklıdır ve güvenilirliğiyle UDP’den ayrılır. Week 1 materyalinde (sayfa 6) TCP/IP yığını açıklanırken belirtilmiştir.",
        },
        {
          question: "C# dilinde değişken tanımlarken ne gereklidir?",
          options: [
            "A) Yalnızca değişken adı",
            "B) Veri türü ve değişken adı",
            "C) Yalnızca veri türü",
            "D) Değişken adı ve operatör",
            "E) Değişken adı ve yorum satırı",
          ],
          correct: "B) Veri türü ve değişken adı",
          explanation:
            "C#, kesin tipli bir dildir ve değişken tanımlarken veri türünün (örneğin, int, string) ve değişken adının belirtilmesi zorunludur. Bu, Week 1 materyalinde (sayfa 21) C# veri türleri ve değişkenler bölümünde açıklanmıştır.",
        },
        {
          question: "HTTPS’nin temel farkı nedir?",
          options: [
            "A) Daha hızlı veri aktarımı sağlar",
            "B) HTTP’yi şifreleyerek güvenli iletişim sunar",
            "C) Durumlu bir protokoldür",
            "D) Yalnızca istemci tarafında çalışır",
            "E) Daha az başlık içerir",
          ],
          correct: "B) HTTP’yi şifreleyerek güvenli iletişim sunar",
          explanation:
            "HTTPS, HTTP’nin güvenli sürümüdür ve SSL/TLS ile şifreleme yaparak gizlilik, kimlik doğrulama ve veri bütünlüğü sağlar. Week 1 materyalinde (sayfa 12) HTTPS başlığı altında detaylandırılmıştır.",
        },
        {
          question: ".NET Core’un platformlar arası doğası neyi ifade eder?",
          options: [
            "A) Yalnızca Windows’ta çalışır",
            "B) Windows, macOS ve Linux’ta çalışabilir",
            "C) Yalnızca web uygulamaları için uygundur",
            "D) Daha az performans sunar",
            "E) Kapalı kaynak bir framework’tür",
          ],
          correct: "B) Windows, macOS ve Linux’ta çalışabilir",
          explanation:
            ".NET Core, platformlar arası bir framework’tür ve farklı işletim sistemlerinde çalışabilir. Bu, Week 1 materyalinde (sayfa 23) .NET Core’un tanıtımı ve faydaları kısmında belirtilmiştir.",
        },
        {
          question: "DNS’nin temel amacı nedir?",
          options: [
            "A) Verileri şifrelemek",
            "B) Alan adlarını IP adreslerine çevirmek",
            "C) HTTP isteklerini yönlendirmek",
            "D) Port numaralarını tanımlamak",
            "E) Sunucu yanıtlarını hızlandırmak",
          ],
          correct: "B) Alan adlarını IP adreslerine çevirmek",
          explanation:
            "DNS (Alan Adı Sistemi), insan tarafından okunabilir alan adlarını (örneğin, www.example.com) makine tarafından okunabilir IP adreslerine çevirir. Bu, Week 1 materyalinde (sayfa 12) DNS başlığı altında açıklanmıştır.",
        },
        {
          question: "IPv6’nın IPv4’e göre en büyük avantajı nedir?",
          options: [
            "A) Daha az adres alanı sunar",
            "B) Daha geniş adres alanı sağlar",
            "C) Daha az güvenli bir yapıdadır",
            "D) Daha yavaş çalışır",
            "E) Fiziksel adresleme yapar",
          ],
          correct: "B) Daha geniş adres alanı sağlar",
          explanation:
            "IPv6, 128-bit adreslerle IPv4’ün 32-bit adreslerine kıyasla çok daha büyük bir adres alanı sunar (340 undesilyon adres). Bu, Week 1 materyalinde (sayfa 14) IPv4 - IPv6 karşılaştırmasında vurgulanmıştır.",
        },
        {
          question: "Port numaralarının temel amacı nedir?",
          options: [
            "A) Cihazları fiziksel olarak adreslemek",
            "B) Veri şifrelemesini sağlamak",
            "C) Bir cihazda çalışan hizmetleri tanımlamak",
            "D) Ağ katmanlarını birleştirmek",
            "E) IP adreslerini saklamak",
          ],
          correct: "C) Bir cihazda çalışan hizmetleri tanımlamak",
          explanation:
            "Port numaraları, bir cihazda çalışan belirli süreçleri veya hizmetleri tanımlar (örneğin, HTTP için 80). Bu, Week 1 materyalinde (sayfa 16) port numaraları bölümünde açıklanmıştır.",
        },
        {
          question: "Soket programlamada istemci soketinin ilk adımı nedir?",
          options: [
            "A) Bağlantıları dinlemek",
            "B) İstemci soketi oluşturmak",
            "C) Sunucudan yanıt almak",
            "D) Veritabanına bağlanmak",
            "E) Port numarasını kapatmak",
          ],
          correct: "B) İstemci soketi oluşturmak",
          explanation:
            "Soket programlamada istemci, önce bir soket oluşturur, ardından sunucuya bağlanır. Bu, Week 1 materyalinde (sayfa 18) kavramsal soket iletişim akışında belirtilmiştir.",
        },
        {
          question: "HTTP durum kodu ‘404’ neyi ifade eder?",
          options: [
            "A) İstek başarılı",
            "B) Kaynak bulunamadı",
            "C) Sunucu hatası",
            "D) Yönlendirme gerekiyor",
            "E) Yetkisiz erişim",
          ],
          correct: "B) Kaynak bulunamadı",
          explanation:
            "HTTP durum kodu ‘404’, istemcinin istediği kaynağın sunucuda bulunamadığını gösterir. Bu, Week 1 materyalinde (sayfa 11) HTTP durum kodları bölümünde açıklanmıştır.",
        },
        {
          question:
            "TCP/IP yığınında Internet Katmanı’nın temel protokolü hangisidir?",
          options: ["A) HTTP", "B) TCP", "C) IP", "D) UDP", "E) DNS"],
          correct: "C) IP",
          explanation:
            "Internet Katmanı, veri paketlerinin yönlendirilmesinden sorumludur ve temel protokolü IP’dir (Internet Protokolü). Bu, Week 1 materyalinde (sayfa 7) TCP/IP yığını katmanlarında belirtilmiştir.",
        },
        {
          question: "C#’ta ‘int’ veri türü neyi temsil eder?",
          options: [
            "A) Metin dizilerini",
            "B) Tamsayı sayıları",
            "C) Ondalık sayıları",
            "D) Boole değerlerini",
            "E) Tarih ve saati",
          ],
          correct: "B) Tamsayı sayıları",
          explanation:
            "C#’ta ‘int’ veri türü, tamsayı sayıları (örneğin, -10, 0, 5) temsil eder. Bu, Week 1 materyalinde (sayfa 21) veri türleri bölümünde açıklanmıştır.",
        },
        {
          question: "HTTP isteğinin gövdesi hangi durumlarda isteğe bağlıdır?",
          options: [
            "A) GET isteğinde",
            "B) POST isteğinde",
            "C) DELETE isteğinde",
            "D) OPTIONS isteğinde",
            "E) HEAD isteğinde",
          ],
          correct: "B) POST isteğinde",
          explanation:
            "HTTP isteğinin gövdesi, genellikle veri gönderen metotlarda (örneğin, POST) kullanılır ve isteğe bağlıdır. GET gibi metotlarda gövde tipik olarak yoktur. Bu, Week 1 materyalinde (sayfa 8) HTTP istek yapısı bölümünde belirtilmiştir.",
        },
        {
          question: "‘Content-Type’ başlığı neyi belirtir?",
          options: [
            "A) İsteğin hedef sunucusunu",
            "B) Yanıt gövdesinin medya türünü",
            "C) İstemcinin dil tercihini",
            "D) Yanıtın oluşturulma tarihini",
            "E) Önbellekleme yönergelerini",
          ],
          correct: "B) Yanıt gövdesinin medya türünü",
          explanation:
            "‘Content-Type’ başlığı, yanıt gövdesinin medya türünü (örneğin, ‘text/html’, ‘application/json’) belirtir. Bu, Week 1 materyalinde (sayfa 11) yaygın HTTP başlıkları bölümünde açıklanmıştır.",
        },
        {
          question: "DNS çözümleme sürecinde ilk adım nedir?",
          options: [
            "A) Kök DNS sunucusuna sorgu",
            "B) İstemciden DNS sorgusu",
            "C) TLD sunucusuna yönlendirme",
            "D) IP adresinin önbelleğe alınması",
            "E) Yetkili ad sunucusuna sorgu",
          ],
          correct: "B) İstemciden DNS sorgusu",
          explanation:
            "DNS çözümleme süreci, istemcinin bir alan adı için IP adresini bulmak üzere DNS çözümleyicisine sorgu göndermesiyle başlar. Bu, Week 1 materyalinde (sayfa 13) DNS çözümleme adımlarıyla detaylandırılmıştır.",
        },
        {
          question: "IPv4 adres yapısı nasıl gösterilir?",
          options: [
            "A) Onaltılık gösterimle",
            "B) Noktalı ondalık gösterimle",
            "C) İkili gösterimle",
            "D) Harf ve rakam kombinasyonuyla",
            "E) Yalnızca rakamsal dizilerle",
          ],
          correct: "B) Noktalı ondalık gösterimle",
          explanation:
            "IPv4 adresleri, 32-bit uzunluğunda olup noktalı ondalık gösterimle yazılır (örneğin, 192.168.1.1). Bu, Week 1 materyalinde (sayfa 14) IPv4 adres yapısı kısmında belirtilmiştir.",
        },
        {
          question: "‘User-Agent’ başlığı neyi tanımlar?",
          options: [
            "A) Sunucunun alan adını",
            "B) İstemci yazılımını ve sistemini",
            "C) Yanıtın içerik uzunluğunu",
            "D) Önbellekleme yönergelerini",
            "E) İsteğin tarihini",
          ],
          correct: "B) İstemci yazılımını ve sistemini",
          explanation:
            "‘User-Agent’ başlığı, isteği yapan istemci yazılımını (örneğin, tarayıcı) ve işletim sistemini tanımlar. Bu, Week 1 materyalinde (sayfa 11) HTTP başlıkları bölümünde açıklanmıştır.",
        },
        {
          question: "HTTP metodu ‘DELETE’ neyi ifade eder?",
          options: [
            "A) Bir kaynağı almak",
            "B) Bir kaynağı silmek",
            "C) Bir kaynağı güncellemek",
            "D) Bir sunucuya veri göndermek",
            "E) İletişim seçeneklerini sormak",
          ],
          correct: "B) Bir kaynağı silmek",
          explanation:
            "‘DELETE’ metodu, bir URI tarafından tanımlanan bir kaynağı silmek için kullanılır. Güvenli değildir ama idempotenttir. Bu, Week 1 materyalinde (sayfa 10) HTTP metotları bölümünde belirtilmiştir.",
        },
        {
          question: "İyi bilinen portlar hangi aralıkta bulunur?",
          options: [
            "A) 1024-49151",
            "B) 49152-65535",
            "C) 0-1023",
            "D) 10000-20000",
            "E) 80-443",
          ],
          correct: "C) 0-1023",
          explanation:
            "İyi bilinen portlar, yaygın hizmetler için ayrılmış olup 0-1023 aralığındadır (örneğin, HTTP: 80). Bu, Week 1 materyalinde (sayfa 16) port numaraları bölümünde açıklanmıştır.",
        },
        {
          question: "Soket programlamada sunucu soketinin temel işlevi nedir?",
          options: [
            "A) Sunucuya bağlanmak",
            "B) Bağlantıları dinlemek",
            "C) Veriyi şifrelemek",
            "D) IP adresini çözmek",
            "E) İstemciye veri göndermek",
          ],
          correct: "B) Bağlantıları dinlemek",
          explanation:
            "Sunucu soketleri, istemcilerden gelen bağlantıları dinler ve kabul eder. Bu, Week 1 materyalinde (sayfa 18) soket iletişim akışında belirtilmiştir.",
        },
        {
          question:
            ".NET Core ile konsol uygulaması oluşturmak için hangi komut kullanılır?",
          options: [
            "A) dotnet build",
            "B) dotnet run",
            "C) dotnet new console",
            "D) dotnet publish",
            "E) dotnet start",
          ],
          correct: "C) dotnet new console",
          explanation:
            ".NET Core’da yeni bir konsol uygulaması oluşturmak için ‘dotnet new console’ komutu kullanılır. Bu, Week 1 materyalinde (sayfa 25) konsol uygulaması oluşturma adımlarında açıklanmıştır.",
        },
        {
          question: "TCP/IP yığınında kapsülleme sürecinde ne olur?",
          options: [
            "A) Veriler şifrelenir",
            "B) Her katman veriye kendi başlığını ekler",
            "C) Veriler fiziksel olarak iletilir",
            "D) Veriler sıralı hale getirilir",
            "E) IP adresleri çözümlenir",
          ],
          correct: "B) Her katman veriye kendi başlığını ekler",
          explanation:
            "Kapsülleme, TCP/IP yığınında verilerin her katmanda başlıklarla sarılması sürecidir. Bu, Week 1 materyalinde (sayfa 7) kapsülleme açıklamasında detaylandırılmıştır.",
        },
        {
          question: "HTTP durum kodu ‘200’ neyi gösterir?",
          options: [
            "A) İstek başarısız",
            "B) İstek başarılı",
            "C) Kaynak taşınmış",
            "D) İstemci hatası",
            "E) Sunucu hatası",
          ],
          correct: "B) İstek başarılı",
          explanation:
            "HTTP durum kodu ‘200 OK’, isteğin başarılı olduğunu ve sunucunun istenen kaynağı döndürdüğünü gösterir. Bu, Week 1 materyalinde (sayfa 11) HTTP durum kodları bölümünde belirtilmiştir.",
        },
        {
          question: "C#’ta mantıksal ‘VE’ operatörü hangisidir?",
          options: ["A) ||", "B) &&", "C) !", "D) ==", "E) !="],
          correct: "B) &&",
          explanation:
            "C#’ta mantıksal ‘VE’ operatörü ‘&&’ ile temsil edilir ve iki koşulun da doğru olması durumunda true döner. Bu, Week 1 materyalinde (sayfa 23) mantıksal operatörler örneğinde açıklanmıştır.",
        },
        {
          question: "İnternet Programlama’nın temel amacı nedir?",
          options: [
            "A) Donanım tasarımı yapmak",
            "B) İnternet üzerinden uygulamalar geliştirmek",
            "C) Fiziksel ağları kurmak",
            "D) Veritabanı yönetimini sağlamak",
            "E) İşletim sistemi geliştirmek",
          ],
          correct: "B) İnternet üzerinden uygulamalar geliştirmek",
          explanation:
            "İnternet Programlama, internet üzerinden çalışan uygulamalar geliştirme sürecidir ve dünya çapında iletişimi mümkün kılar. Bu, Week 1 materyalinde (sayfa 1) ‘İnternet Programlama Nedir?’ başlığı altında tanımlanmıştır.",
        },

        {
          question: "Sürüm kontrolü nedir?",
          options: [
            "A) Kodun yalnızca son halini saklayan bir sistem",
            "B) Dosyalardaki değişiklikleri zaman içinde kaydeden bir sistem",
            "C) Yazılım projelerini şifreleyen bir araç",
            "D) Yalnızca tek bir geliştiricinin kullanabileceği bir yapı",
            "E) Kodun fiziksel yedeğini oluşturan bir donanım",
          ],
          correct:
            "B) Dosyalardaki değişiklikleri zaman içinde kaydeden bir sistem",
          explanation:
            "Sürüm kontrolü, bir dosya veya dosya kümesindeki değişiklikleri zaman içinde kaydederek belirli sürümleri geri çağırabilmenizi sağlar. Week 2 materyalinde (sayfa 1), sürüm kontrolü 'kodunuz için detaylı bir tarih kitabı' olarak tanımlanmıştır.",
        },
        {
          question: "Sürüm kontrolünün temel faydalarından biri hangisidir?",
          options: [
            "A) Kodun yalnızca tek bir sürümünü tutar",
            "B) Birden fazla geliştiricinin aynı anda çalışmasını sağlar",
            "C) Kodun derlenmesini hızlandırır",
            "D) Yalnızca yerel depolarda çalışır",
            "E) Donanım arızalarını önler",
          ],
          correct:
            "B) Birden fazla geliştiricinin aynı anda çalışmasını sağlar",
          explanation:
            "Sürüm kontrolü, işbirliğini mümkün kılar ve birden fazla geliştiricinin aynı proje üzerinde birbirlerinin çalışmalarını bozmadan çalışmasına olanak tanır. Bu, Week 2 materyalinde (sayfa 2) 'İşbirliği' başlığı altında açıklanmıştır.",
        },
        {
          question:
            "Merkezi Sürüm Kontrol Sistemleri’nin (MSKS) en büyük sınırlaması nedir?",
          options: [
            "A) Hızlı işlemler sunar",
            "B) Tek hata noktasına sahiptir",
            "C) Esnek dallanma sağlar",
            "D) Yerel depolarda çalışır",
            "E) İşbirliğini engeller",
          ],
          correct: "B) Tek hata noktasına sahiptir",
          explanation:
            "Merkezi Sürüm Kontrol Sistemleri’nde (MSKS) tek bir merkezi sunucu bulunur ve bu sunucu çökerse kimse çalışamaz. Bu, Week 2 materyalinde (sayfa 3) MSKS’nin sınırlamaları olarak belirtilmiştir.",
        },
        {
          question: "Git hangi tür sürüm kontrol sistemidir?",
          options: [
            "A) Merkezi Sürüm Kontrol Sistemi",
            "B) Dağıtık Sürüm Kontrol Sistemi",
            "C) Hibrit Sürüm Kontrol Sistemi",
            "D) Yerel Sürüm Kontrol Sistemi",
            "E) Bulut Sürüm Kontrol Sistemi",
          ],
          correct: "B) Dağıtık Sürüm Kontrol Sistemi",
          explanation:
            "Git, her geliştiricinin yerel bir depo ile çalıştığı ve tüm sürüm geçmişini içerdiği bir Dağıtık Sürüm Kontrol Sistemi’dir (DSKS). Bu, Week 2 materyalinde (sayfa 3) açıkça belirtilmiştir.",
        },
        {
          question: "Git’i kurduktan sonra ilk yapılandırma adımı nedir?",
          options: [
            "A) Yeni bir dal oluşturmak",
            "B) Kullanıcı adı ve e-posta ayarlamak",
            "C) Uzak depo eklemek",
            "D) Değişiklikleri commit etmek",
            "E) Depoyu klonlamak",
          ],
          correct: "B) Kullanıcı adı ve e-posta ayarlamak",
          explanation:
            "Git’in commit’leri kimliğinizle ilişkilendirmesi için kullanıcı adı ve e-posta adresini yapılandırmak gerekir. Bu, Week 2 materyalinde (sayfa 4) ‘Git Kullanıcı Adı ve E-postasını Yapılandırma’ başlığı altında açıklanmıştır.",
        },
        {
          question: "‘git init’ komutu ne yapar?",
          options: [
            "A) Uzak bir depoyu klonlar",
            "B) Mevcut dizini bir Git deposuna dönüştürür",
            "C) Değişiklikleri uzak depoya gönderir",
            "D) Birleştirme çakışmalarını çözer",
            "E) Yeni bir özellik dalı oluşturur",
          ],
          correct: "B) Mevcut dizini bir Git deposuna dönüştürür",
          explanation:
            "‘git init’ komutu, mevcut dizinde bir Git deposu başlatır ve .git klasörünü oluşturur. Bu, Week 2 materyalinde (sayfa 4) ‘Yerel Bir Depo Oluşturma’ bölümünde detaylandırılmıştır.",
        },
        {
          question:
            "Değişiklikleri hazırlamak için hangi Git komutu kullanılır?",
          options: [
            "A) git commit",
            "B) git push",
            "C) git add",
            "D) git merge",
            "E) git log",
          ],
          correct: "C) git add",
          explanation:
            "‘git add’ komutu, değişiklikleri hazırlama alanına (indeks) ekler ve bir sonraki commit’e dahil edilecek değişiklikleri seçmenizi sağlar. Week 2 materyalinde (sayfa 5) ‘Değişiklikleri Hazırlama’ başlığı altında açıklanmıştır.",
        },
        {
          question:
            "Tüm değiştirilmiş dosyaları hazırlamak için hangi komut kullanılır?",
          options: [
            "A) git add <dosyaadı>",
            "B) git add .",
            "C) git commit -m",
            "D) git push origin main",
            "E) git branch",
          ],
          correct: "B) git add .",
          explanation:
            "‘git add .’ komutu, mevcut dizindeki ve alt dizinlerdeki tüm değiştirilmiş dosyaları hazırlar. Bu, Week 2 materyalinde (sayfa 6) ‘git add Komutunun Yaygın Kullanımları’ kısmında belirtilmiştir.",
        },
        {
          question: "Bir commit mesajı yazarken en iyi uygulama nedir?",
          options: [
            "A) Uzun ve karmaşık bir mesaj yazmak",
            "B) ‘Değişiklik yapıldı’ gibi genel bir ifade kullanmak",
            "C) Özlü, açıklayıcı ve emredici kipte mesaj yazmak",
            "D) Mesaj yazmayı tamamen atlamak",
            "E) Yalnızca tarih bilgisi eklemek",
          ],
          correct: "C) Özlü, açıklayıcı ve emredici kipte mesaj yazmak",
          explanation:
            "Commit mesajları özlü, açıklayıcı olmalı ve emredici kipte yazılmalıdır (örneğin, ‘Özellik ekle’). Bu, Week 2 materyalinde (sayfa 7) ‘Commit Mesajları İçin En İyi Uygulamalar’ başlığı altında vurgulanmıştır.",
        },
        {
          question:
            "Commit geçmişini görüntülemek için hangi komut kullanılır?",
          options: [
            "A) git status",
            "B) git log",
            "C) git branch",
            "D) git fetch",
            "E) git remote",
          ],
          correct: "B) git log",
          explanation:
            "‘git log’ komutu, commit geçmişini ters kronolojik sırayla gösterir. Week 2 materyalinde (sayfa 8) ‘Commit Geçmişini Görüntüleme’ başlığı altında detaylandırılmıştır.",
        },
        {
          question: "‘git log --oneline’ neyi sağlar?",
          options: [
            "A) Commit farklarını detaylı gösterir",
            "B) Commit’lerin tek satırlık özetini listeler",
            "C) Yeni bir dal oluşturur",
            "D) Uzak depodan değişiklik çeker",
            "E) Çakışmaları çözer",
          ],
          correct: "B) Commit’lerin tek satırlık özetini listeler",
          explanation:
            "‘git log --oneline’ seçeneği, commit geçmişini kompakt, tek satırlık özetler halinde gösterir. Bu, Week 2 materyalinde (sayfa 8) ‘Yaygın git log Seçenekleri’ kısmında açıklanmıştır.",
        },
        {
          question: "‘.gitignore’ dosyasının amacı nedir?",
          options: [
            "A) Commit mesajlarını saklar",
            "B) Sürüm kontrolünden belirli dosyaları hariç tutar",
            "C) Yeni dallar oluşturur",
            "D) Uzak depoları listeler",
            "E) Değişiklikleri birleştirir",
          ],
          correct: "B) Sürüm kontrolünden belirli dosyaları hariç tutar",
          explanation:
            "‘.gitignore’ dosyası, geçici dosyalar gibi sürüm kontrolüne dahil edilmemesi gereken dosyaları ve dizinleri belirtir. Week 2 materyalinde (sayfa 9) ‘Dosyaları Yoksayma’ başlığı altında açıklanmıştır.",
        },
        {
          question: "Yeni bir dal oluşturmak için hangi komut kullanılır?",
          options: [
            "A) git merge",
            "B) git branch <dal-adı>",
            "C) git add",
            "D) git pull",
            "E) git commit",
          ],
          correct: "B) git branch <dal-adı>",
          explanation:
            "‘git branch <dal-adı>’ komutu, yeni bir dal oluşturur ancak sizi o dala geçirmez. Bu, Week 2 materyalinde (sayfa 11) ‘Temel Dal İşlemleri’ kısmında belirtilmiştir.",
        },
        {
          question: "Bir dala geçmek için hangi komut tercih edilir?",
          options: [
            "A) git branch",
            "B) git switch <dal-adı>",
            "C) git log",
            "D) git push",
            "E) git stash",
          ],
          correct: "B) git switch <dal-adı>",
          explanation:
            "‘git switch <dal-adı>’, modern Git’te dallar arasında geçiş yapmak için önerilen, daha odaklanmış bir komuttur. Week 2 materyalinde (sayfa 11) ‘Bir Dala Geç’ başlığı altında açıklanmıştır.",
        },
        {
          question:
            "Yeni bir dal oluşturup hemen ona geçmek için hangi komut kullanılır?",
          options: [
            "A) git branch <dal-adı>",
            "B) git checkout -b <dal-adı>",
            "C) git merge",
            "D) git add .",
            "E) git remote add",
          ],
          correct: "B) git checkout -b <dal-adı>",
          explanation:
            "‘git checkout -b <dal-adı>’ komutu, yeni bir dal oluşturur ve hemen ona geçiş yapar. Week 2 materyalinde (sayfa 11) ‘Tek Komutta Yeni Bir Dal Oluşturun ve Ona Geçin’ kısmında belirtilmiştir.",
        },
        {
          question: "Dalları birleştirmek için hangi komut kullanılır?",
          options: [
            "A) git branch",
            "B) git merge <dal-adı>",
            "C) git commit",
            "D) git push",
            "E) git log",
          ],
          correct: "B) git merge <dal-adı>",
          explanation:
            "‘git merge <dal-adı>’ komutu, bir daldaki değişiklikleri mevcut dala birleştirir. Week 2 materyalinde (sayfa 13) ‘Dalları Birleştirme’ başlığı altında detaylandırılmıştır.",
        },
        {
          question: "Birleştirme çakışması nasıl çözülür?",
          options: [
            "A) Otomatik olarak çözülür",
            "B) Çakışan dosyaları manuel olarak düzenleyip commit edilir",
            "C) Yeni bir dal oluşturulur",
            "D) Uzak depodan çekilir",
            "E) Değişiklikler silinir",
          ],
          correct:
            "B) Çakışan dosyaları manuel olarak düzenleyip commit edilir",
          explanation:
            "Birleştirme çakışmaları, çakışan dosyalar manuel olarak düzenlenip ‘git add’ ve ‘git commit’ ile tamamlanır. Week 2 materyalinde (sayfa 14) ‘Birleştirme Çakışmalarını Çözme’ başlığı altında açıklanmıştır.",
        },
        {
          question: "Uzak depoların temel amacı nedir?",
          options: [
            "A) Yerel değişiklikleri silmek",
            "B) İşbirliği ve yedekleme sağlamak",
            "C) Kodun derlenmesini hızlandırmak",
            "D) Dalları birleştirmek",
            "E) Commit geçmişini gizlemek",
          ],
          correct: "B) İşbirliği ve yedekleme sağlamak",
          explanation:
            "Uzak depolar, işbirliğini kolaylaştırır ve kod tabanının bulutta yedeklenmesini sağlar. Week 2 materyalinde (sayfa 17) ‘Uzak Depolar’ başlığı altında belirtilmiştir.",
        },
        {
          question:
            "Uzak bir depoyu yerel makineye indirmek için hangi komut kullanılır?",
          options: [
            "A) git push",
            "B) git clone <url>",
            "C) git merge",
            "D) git add",
            "E) git branch",
          ],
          correct: "B) git clone <url>",
          explanation:
            "‘git clone <url>’ komutu, uzak bir deponun yerel kopyasını oluşturur. Week 2 materyalinde (sayfa 17) ‘Uzak Depoyu Klonlama’ başlığı altında açıklanmıştır.",
        },
        {
          question:
            "Yerel bir depoya uzak depo eklemek için hangi komut kullanılır?",
          options: [
            "A) git remote add <ad> <url>",
            "B) git pull",
            "C) git fetch",
            "D) git commit",
            "E) git switch",
          ],
          correct: "A) git remote add <ad> <url>",
          explanation:
            "‘git remote add <ad> <url>’ komutu, yerel depoyu bir uzak depoya bağlar. Week 2 materyalinde (sayfa 18) ‘Uzak Depo Ekleme’ başlığı altında detaylandırılmıştır.",
        },
        {
          question:
            "Yerel commit’leri uzak depoya göndermek için hangi komut kullanılır?",
          options: [
            "A) git pull",
            "B) git push <uzak-adı> <dal-adı>",
            "C) git fetch",
            "D) git log",
            "E) git stash",
          ],
          correct: "B) git push <uzak-adı> <dal-adı>",
          explanation:
            "‘git push <uzak-adı> <dal-adı>’ komutu, yerel commit’leri uzak depoya yükler. Week 2 materyalinde (sayfa 19) ‘Değişiklikleri Uzağa Gönderme’ başlığı altında açıklanmıştır.",
        },
        {
          question:
            "Uzak depodan değişiklikleri çekmek için hangi komut kullanılır?",
          options: [
            "A) git push",
            "B) git pull <uzak-adı> <dal-adı>",
            "C) git add",
            "D) git branch",
            "E) git merge",
          ],
          correct: "B) git pull <uzak-adı> <dal-adı>",
          explanation:
            "‘git pull <uzak-adı> <dal-adı>’ komutu, uzak depodan değişiklikleri çeker ve yerel dala birleştirir. Week 2 materyalinde (sayfa 21) ‘Değişiklikleri Uzaktan Çekme’ başlığı altında belirtilmiştir.",
        },
        {
          question: "‘git fetch’ ile ‘git pull’ arasındaki temel fark nedir?",
          options: [
            "A) git fetch değişiklikleri birleştirir, git pull getirmez",
            "B) git fetch değişiklikleri getirir ama birleştirmez, git pull birleştirir",
            "C) git fetch yerel dalı siler, git pull korur",
            "D) git fetch yalnızca dalları listeler, git pull getirir",
            "E) git fetch uzak depoları ekler, git pull kaldırır",
          ],
          correct:
            "B) git fetch değişiklikleri getirir ama birleştirmez, git pull birleştirir",
          explanation:
            "‘git fetch’ değişiklikleri indirir ancak birleştirmez; ‘git pull’ ise getirir ve birleştirir. Week 2 materyalinde (sayfa 22) ‘Değişiklikleri Uzaktan Getirme’ başlığı altında açıklanmıştır.",
        },
        {
          question: "Uzak bağlantıları listelemek için hangi komut kullanılır?",
          options: [
            "A) git branch",
            "B) git remote -v",
            "C) git log",
            "D) git commit",
            "E) git switch",
          ],
          correct: "B) git remote -v",
          explanation:
            "‘git remote -v’ komutu, uzak bağlantıları URL’leriyle birlikte listeler. Week 2 materyalinde (sayfa 23) ‘Uzaklarla Çalışma’ başlığı altında belirtilmiştir.",
        },
        {
          question: "Çatallama ve Çekme İsteği modeli hangi amaçla kullanılır?",
          options: [
            "A) Yerel depoları silmek",
            "B) İşbirliğine dayalı katkı sağlamak",
            "C) Kodun derlenmesini hızlandırmak",
            "D) Dalları birleştirmek",
            "E) Commit geçmişini gizlemek",
          ],
          correct: "B) İşbirliğine dayalı katkı sağlamak",
          explanation:
            "Çatallama ve Çekme İsteği modeli, açık kaynak projelerine veya dağıtık ekiplere katkı sağlamak için kullanılır. Week 2 materyalinde (sayfa 27) ‘İşbirliği İş Akışları’ başlığı altında açıklanmıştır.",
        },
        {
          question: "Özellik Dalı İş Akışı’nda ana dalın temel özelliği nedir?",
          options: [
            "A) Sürekli değişir",
            "B) Kararlı ve üretime hazırdır",
            "C) Yalnızca test için kullanılır",
            "D) Uzak depolarla senkronize edilmez",
            "E) Yeni özellikler için kullanılır",
          ],
          correct: "B) Kararlı ve üretime hazırdır",
          explanation:
            "Özellik Dalı İş Akışı’nda ana dal (main) kararlı ve üretime hazır tutulur. Week 2 materyalinde (sayfa 28) ‘Özellik Dalı İş Akışı Adımları’ kısmında belirtilmiştir.",
        },
        {
          question: "Paylaşılan depolarda en iyi uygulama olarak ne önerilir?",
          options: [
            "A) Doğrudan ana dala commit yapmak",
            "B) Özellik dalları kullanmak",
            "C) Commit mesajlarını atlamak",
            "D) Değişiklikleri nadiren göndermek",
            "E) Kod incelemesini ihmal etmek",
          ],
          correct: "B) Özellik dalları kullanmak",
          explanation:
            "Paylaşılan depolarda özellik dalları kullanmak, ana dalın kararlı kalmasını sağlar. Week 2 materyalinde (sayfa 28) ‘Paylaşılan Depolar İçin En İyi Uygulamalar’ başlığı altında vurgulanmıştır.",
        },
        {
          question: "Etiketleme (tagging) hangi amaçla kullanılır?",
          options: [
            "A) Değişiklikleri hazırlamak",
            "B) Yayın noktalarını işaretlemek",
            "C) Uzak depoları eklemek",
            "D) Çakışmaları çözmek",
            "E) Commit geçmişini silmek",
          ],
          correct: "B) Yayın noktalarını işaretlemek",
          explanation:
            "Etiketleme, yayın noktalarını (örneğin, v1.0) işaretlemek için kullanılır. Week 2 materyalinde (sayfa 29) ‘Etiketleme: Yayın Noktalarını İşaretleme’ başlığı altında açıklanmıştır.",
        },
        {
          question: "Saklama (stashing) ne için kullanılır?",
          options: [
            "A) Değişiklikleri uzak depoya göndermek",
            "B) Devam eden çalışmayı geçici olarak kaydetmek",
            "C) Yeni bir dal oluşturmak",
            "D) Commit geçmişini görüntülemek",
            "E) Uzak bağlantıları listelemek",
          ],
          correct: "B) Devam eden çalışmayı geçici olarak kaydetmek",
          explanation:
            "Saklama, tamamlanmamış değişiklikleri geçici olarak kaydedip başka bir işe geçmenizi sağlar. Week 2 materyalinde (sayfa 30) ‘Saklama: Devam Eden Çalışmayı Geçici Olarak Kaydetme’ başlığı altında belirtilmiştir.",
        },
        {
          question:
            "Saklanmış değişiklikleri uygulamak ve saklama listesinden kaldırmak için hangi komut kullanılır?",
          options: [
            "A) git stash apply",
            "B) git stash pop",
            "C) git stash list",
            "D) git stash clear",
            "E) git stash push",
          ],
          correct: "B) git stash pop",
          explanation:
            "‘git stash pop’ komutu, saklanmış değişiklikleri uygular ve saklama listesinden kaldırır. Week 2 materyalinde (sayfa 31) ‘Saklanmış Değişiklikleri Uygulama’ başlığı altında açıklanmıştır.",
        },

        {
          question: "HTTP nedir?",
          options: [
            "A) Bir programlama dili",
            "B) World Wide Web'deki iletişimin omurgası olan protokol",
            "C) Bir veritabanı yönetim sistemi",
            "D) Yalnızca yerel ağlar için kullanılan bir araç",
            "E) Bir dosya sıkıştırma formatı",
          ],
          correct: "B) World Wide Web'deki iletişimin omurgası olan protokol",
          explanation:
            "HTTP (Köprü Metni Aktarım Protokolü), World Wide Web'deki iletişimin temel protokolüdür. Week 3 materyalinde (sayfa 1), HTTP'nin web uygulamalarının temelini oluşturduğu ve istemci-sunucu iletişimini sağladığı belirtilmiştir.",
        },
        {
          question: "Bir HTTP isteğinin temel bölümleri nelerdir?",
          options: [
            "A) İstek Satırı, Başlıklar, Gövde (isteğe bağlı)",
            "B) Yalnızca İstek Satırı",
            "C) Başlıklar ve Durum Kodu",
            "D) Gövde ve URI",
            "E) Yalnızca Başlıklar",
          ],
          correct: "A) İstek Satırı, Başlıklar, Gövde (isteğe bağlı)",
          explanation:
            "Bir HTTP isteği, İstek Satırı, Başlıklar ve isteğe bağlı bir Gövde'den oluşur. Week 3 materyalinde (sayfa 1), bu yapı 'Bir HTTP İsteğinin Anatomisi' başlığı altında detaylandırılmıştır.",
        },
        {
          question: "HTTP İstek Satırı hangi bileşenleri içerir?",
          options: [
            "A) Durum Kodu, URI, HTTP Sürümü",
            "B) HTTP Metodu, URI, HTTP Sürümü",
            "C) Başlıklar, Gövde, Metot",
            "D) URI, Durum Mesajı, Content-Type",
            "E) HTTP Sürümü, Host, Accept",
          ],
          correct: "B) HTTP Metodu, URI, HTTP Sürümü",
          explanation:
            "HTTP İstek Satırı, HTTP Metodu, URI (Tekdüzen Kaynak Tanımlayıcı) ve HTTP Sürümünden oluşur. Week 3 materyalinde (sayfa 2), bu bileşenler örnekle (örneğin, GET /api/products HTTP/1.1) açıklanmıştır.",
        },
        {
          question: "HTTP İstek Başlıklarının temel amacı nedir?",
          options: [
            "A) Sunucuya veri göndermek",
            "B) İstek hakkında meta veri sağlamak",
            "C) Yanıtın durumunu belirtmek",
            "D) Kaynağı silmek",
            "E) Yeni bir kaynak oluşturmak",
          ],
          correct: "B) İstek hakkında meta veri sağlamak",
          explanation:
            "HTTP İstek Başlıkları, istemci yetenekleri, kimlik doğrulama bilgileri gibi meta veriler sağlar. Week 3 materyalinde (sayfa 2), başlıkların bağlam ve ek bilgi sunduğu belirtilmiştir.",
        },
        {
          question: "HTTP İstek Gövdesi hangi durumlarda kullanılır?",
          options: [
            "A) Her zaman zorunludur",
            "B) Yalnızca GET isteklerinde",
            "C) POST ve PUT gibi veri gönderen metotlarda",
            "D) Yanıtları önbelleğe almak için",
            "E) Durum kodlarını belirtmek için",
          ],
          correct: "C) POST ve PUT gibi veri gönderen metotlarda",
          explanation:
            "HTTP İstek Gövdesi, genellikle POST ve PUT gibi kaynak oluşturma veya güncelleme için veri gönderen metotlarda kullanılır. Week 3 materyalinde (sayfa 3), bu durum JSON gövdeli bir örnekle açıklanmıştır.",
        },
        {
          question: "Bir HTTP yanıtının temel bölümleri nelerdir?",
          options: [
            "A) Durum Satırı, Başlıklar, Gövde (isteğe bağlı)",
            "B) Yalnızca Durum Satırı",
            "C) Başlıklar ve URI",
            "D) Gövde ve HTTP Metodu",
            "E) Yalnızca Başlıklar",
          ],
          correct: "A) Durum Satırı, Başlıklar, Gövde (isteğe bağlı)",
          explanation:
            "Bir HTTP yanıtı, Durum Satırı, Başlıklar ve isteğe bağlı bir Gövde'den oluşur. Week 3 materyalinde (sayfa 4), bu yapı 'Bir HTTP Yanıtının Anatomisi' başlığı altında detaylandırılmıştır.",
        },
        {
          question: "HTTP Durum Satırı hangi bilgileri içerir?",
          options: [
            "A) HTTP Sürümü, Durum Kodu, Durum Mesajı",
            "B) URI, HTTP Metodu, Başlıklar",
            "C) Durum Kodu, Gövde, Content-Type",
            "D) HTTP Sürümü, Host, Accept",
            "E) Durum Mesajı, Önbellekleme Direktifleri",
          ],
          correct: "A) HTTP Sürümü, Durum Kodu, Durum Mesajı",
          explanation:
            "HTTP Durum Satırı, HTTP Sürümü, Durum Kodu ve Durum Mesajı içerir. Week 3 materyalinde (sayfa 4), örnek olarak 'HTTP/1.1 200 OK' verilmiştir.",
        },
        {
          question: "HTTP Yanıt Gövdesi neyi içerir?",
          options: [
            "A) Yalnızca meta verileri",
            "B) İstenen kaynağı veya hata ayrıntılarını",
            "C) HTTP Metodunu",
            "D) URI’yi",
            "E) Durum Kodunu",
          ],
          correct: "B) İstenen kaynağı veya hata ayrıntılarını",
          explanation:
            "HTTP Yanıt Gövdesi, istenen kaynağı (örneğin, JSON verileri) veya hata mesajlarını içerir. Week 3 materyalinde (sayfa 5), bu durum JSON gövdeli bir örnekle açıklanmıştır.",
        },
        {
          question: "GET HTTP metodunun temel özelliği nedir?",
          options: [
            "A) Yeni kaynak oluşturur",
            "B) Güvenli ve idempotenttir",
            "C) Sunucu durumunu değiştirir",
            "D) Kısmi güncellemeler yapar",
            "E) Yanıtları önbelleğe almaz",
          ],
          correct: "B) Güvenli ve idempotenttir",
          explanation:
            "GET metodu, veri alımı için kullanılır, güvenli (yan etki yaratmaz) ve idempotenttir (tekrarlanan istekler aynı sonucu verir). Week 3 materyalinde (sayfa 7) bu özellikler detaylandırılmıştır.",
        },
        {
          question: "POST HTTP metodunun temel farkı nedir?",
          options: [
            "A) İdempotenttir",
            "B) Veri gönderir ve yan etkileri olabilir",
            "C) Yalnızca meta veri alır",
            "D) Kaynakları siler",
            "E) Önbelleğe alınabilir",
          ],
          correct: "B) Veri gönderir ve yan etkileri olabilir",
          explanation:
            "POST metodu, veri gönderir ve yan etkilere (örneğin, kaynak oluşturma) yol açabilir; idempotent değildir. Week 3 materyalinde (sayfa 7-8) bu özellikler açıklanmıştır.",
        },
        {
          question: "PUT HTTP metodunun amacı nedir?",
          options: [
            "A) Kaynakları silmek",
            "B) Kaynakları güncellemek veya oluşturmak",
            "C) Yalnızca veri almak",
            "D) Kısmi güncellemeler yapmak",
            "E) Sunucu yeteneklerini keşfetmek",
          ],
          correct: "B) Kaynakları güncellemek veya oluşturmak",
          explanation:
            "PUT metodu, mevcut bir kaynağı günceller veya yoksa oluşturur ve idempotenttir. Week 3 materyalinde (sayfa 8) bu amaç örnekle açıklanmıştır.",
        },
        {
          question: "PATCH HTTP metodunun PUT’tan farkı nedir?",
          options: [
            "A) Tam kaynak günceller",
            "B) Kısmi güncellemeler yapar",
            "C) İdempotenttir",
            "D) Veri göndermez",
            "E) Kaynakları siler",
          ],
          correct: "B) Kısmi güncellemeler yapar",
          explanation:
            "PATCH, bir kaynağın yalnızca belirli kısımlarını günceller, PUT ise tüm kaynağı değiştirir. Week 3 materyalinde (sayfa 9-10) bu fark belirtilmiştir.",
        },
        {
          question: "OPTIONS HTTP metodunun amacı nedir?",
          options: [
            "A) Kaynakları güncellemek",
            "B) Sunucu yeteneklerini keşfetmek",
            "C) Veri göndermek",
            "D) Kaynakları silmek",
            "E) Yanıt gövdesini almak",
          ],
          correct: "B) Sunucu yeteneklerini keşfetmek",
          explanation:
            "OPTIONS metodu, bir kaynağın desteklediği HTTP metotlarını ve yeteneklerini öğrenmek için kullanılır. Week 3 materyalinde (sayfa 10) bu amaç açıklanmıştır.",
        },
        {
          question: "HEAD HTTP metodunun GET’ten farkı nedir?",
          options: [
            "A) Yanıt gövdesini içerir",
            "B) Yalnızca başlıkları alır",
            "C) Yan etkileri vardır",
            "D) İdempotent değildir",
            "E) Veri gönderir",
          ],
          correct: "B) Yalnızca başlıkları alır",
          explanation:
            "HEAD metodu, GET gibi çalışır ancak yanıt gövdesini döndürmez, yalnızca başlıkları alır. Week 3 materyalinde (sayfa 11) bu fark detaylandırılmıştır.",
        },
        {
          question: "HTTP Durum Kodları hangi sınıfa aittir: 200 OK?",
          options: [
            "A) 1xx Bilgilendirici",
            "B) 2xx Başarılı",
            "C) 3xx Yönlendirme",
            "D) 4xx İstemci Hatası",
            "E) 5xx Sunucu Hatası",
          ],
          correct: "B) 2xx Başarılı",
          explanation:
            "200 OK, isteğin başarılı olduğunu gösteren 2xx sınıfına aittir. Week 3 materyalinde (sayfa 13) bu kod 'Başarılı' kategorisinde listelenmiştir.",
        },
        {
          question: "404 Not Found hangi durumu belirtir?",
          options: [
            "A) İstek başarılıdır",
            "B) Kaynak bulunamadı",
            "C) Sunucu hatası",
            "D) Yönlendirme gerekiyor",
            "E) Kimlik doğrulama eksik",
          ],
          correct: "B) Kaynak bulunamadı",
          explanation:
            "404 Not Found, istenen kaynağın sunucuda bulunamadığını belirtir. Week 3 materyalinde (sayfa 15) bu durum örneğiyle açıklanmıştır.",
        },
        {
          question: "Content-Type başlığının amacı nedir?",
          options: [
            "A) Gövde boyutunu belirtir",
            "B) Gövdenin medya türünü tanımlar",
            "C) Kimlik doğrulama bilgisi sağlar",
            "D) Önbellekleme süresini belirler",
            "E) Yönlendirme adresini gösterir",
          ],
          correct: "B) Gövdenin medya türünü tanımlar",
          explanation:
            "Content-Type başlığı, gövdenin medya türünü (örneğin, application/json) belirtir. Week 3 materyalinde (sayfa 18) bu amaç detaylandırılmıştır.",
        },
        {
          question: "Authorization başlığı hangi amaçla kullanılır?",
          options: [
            "A) Gövde boyutunu belirtmek",
            "B) İstemcinin kimlik bilgilerini sunmak",
            "C) Önbellekleme direktifleri sağlamak",
            "D) Yanıtın tarihini göstermek",
            "E) Statik dosyaları sunmak",
          ],
          correct: "B) İstemcinin kimlik bilgilerini sunmak",
          explanation:
            "Authorization başlığı, istemcinin kimlik doğrulama bilgilerini (örneğin, Bearer token) sunar. Week 3 materyalinde (sayfa 19) bu kullanım örneğiyle açıklanmıştır.",
        },
        {
          question: "Cache-Control başlığının temel işlevi nedir?",
          options: [
            "A) Kimlik doğrulama sağlamak",
            "B) Önbellekleme davranışını kontrol etmek",
            "C) Gövde türünü belirtmek",
            "D) Sunucu kimliğini göstermek",
            "E) Kaynak silmeyi yönetmek",
          ],
          correct: "B) Önbellekleme davranışını kontrol etmek",
          explanation:
            "Cache-Control başlığı, önbellekleme mekanizmalarını (örneğin, max-age) kontrol eder. Week 3 materyalinde (sayfa 20) bu işlev detaylandırılmıştır.",
        },
        {
          question: "ASP.NET Core’un temel özelliklerinden biri nedir?",
          options: [
            "A) Yalnızca Windows’ta çalışır",
            "B) Platformlar arasıdır",
            "C) Kapalı kaynaktır",
            "D) Yavaş performansa sahiptir",
            "E) Bağımlılık enjeksiyonu desteklemez",
          ],
          correct: "B) Platformlar arasıdır",
          explanation:
            "ASP.NET Core, Windows, macOS ve Linux’ta çalışan platformlar arası bir framework’tür. Week 3 materyalinde (sayfa 20) bu özellik vurgulanmıştır.",
        },
        {
          question:
            "ASP.NET Core’un birleşik programlama modeli neyi ifade eder?",
          options: [
            "A) Yalnızca MVC’yi destekler",
            "B) MVC ve Web API’yi tek bir framework’te birleştirir",
            "C) Eski System.Web.dll’ye dayanır",
            "D) Middleware kullanmaz",
            "E) Statik dosyaları sunmaz",
          ],
          correct: "B) MVC ve Web API’yi tek bir framework’te birleştirir",
          explanation:
            "ASP.NET Core, MVC ve Web API’yi tek bir programlama modelinde birleştirir. Week 3 materyalinde (sayfa 21) bu birleşme açıklanmıştır.",
        },
        {
          question: "ASP.NET Core projesinde Program.cs dosyası neyi yapar?",
          options: [
            "A) Yalnızca denetleyicileri tanımlar",
            "B) Uygulamanın giriş noktasını ve middleware’ı yapılandırır",
            "C) Statik dosyaları sunar",
            "D) Görünümleri oluşturur",
            "E) Veritabanı bağlantısını kurar",
          ],
          correct:
            "B) Uygulamanın giriş noktasını ve middleware’ı yapılandırır",
          explanation:
            "Program.cs, uygulamanın giriş noktasıdır ve middleware pipeline’ını yapılandırır. Week 3 materyalinde (sayfa 23) bu rol belirtilmiştir.",
        },
        {
          question: "ASP.NET Core’da Swagger UI’nin amacı nedir?",
          options: [
            "A) Veritabanı yönetimini sağlar",
            "B) API uç noktalarını test etmeye yarar",
            "C) Statik dosyaları sunar",
            "D) Kimlik doğrulama yapar",
            "E) Hata mesajlarını gizler",
          ],
          correct: "B) API uç noktalarını test etmeye yarar",
          explanation:
            "Swagger UI, API uç noktalarını listeleyen ve test eden bir arayüz sağlar. Week 3 materyalinde (sayfa 24) bu işlev açıklanmıştır.",
        },
        {
          question: "ASP.NET Core’da middleware nedir?",
          options: [
            "A) Veritabanı erişim katmanı",
            "B) İstek ve yanıtları işleyen yazılım bileşenleri",
            "C) Yalnızca denetleyicileri çalıştırır",
            "D) Statik dosya deposu",
            "E) Görünüm oluşturma aracı",
          ],
          correct: "B) İstek ve yanıtları işleyen yazılım bileşenleri",
          explanation:
            "Middleware, ASP.NET Core’da istekleri ve yanıtları işleyen pipeline bileşenleridir. Week 3 materyalinde (sayfa 24) bu tanım verilmiştir.",
        },
        {
          question: "ASP.NET Core’da yönlendirme middleware’i ne yapar?",
          options: [
            "A) Statik dosyaları sunar",
            "B) İstekleri uç noktalara eşler",
            "C) Hata mesajlarını günlüğe kaydeder",
            "D) Kimlik doğrulama yapar",
            "E) Önbellekleme sağlar",
          ],
          correct: "B) İstekleri uç noktalara eşler",
          explanation:
            "Yönlendirme middleware’i (UseRouting), istekleri denetleyicilere veya uç noktalara eşler. Week 3 materyalinde (sayfa 25) bu işlev listelenmiştir.",
        },
        {
          question: "Özel middleware oluşturmanın ilk adımı nedir?",
          options: [
            "A) Bir denetleyici sınıfı oluşturmak",
            "B) InvokeAsync metoduna sahip bir sınıf yazmak",
            "C) Statik dosyaları yapılandırmak",
            "D) Görünüm dosyası eklemek",
            "E) Veritabanı bağlantısı kurmak",
          ],
          correct: "B) InvokeAsync metoduna sahip bir sınıf yazmak",
          explanation:
            "Özel middleware, InvokeAsync metoduna sahip bir sınıf yazılarak oluşturulur. Week 3 materyalinde (sayfa 28) bu adım detaylandırılmıştır.",
        },
        {
          question: "ASP.NET Core’da middleware sırası neden önemlidir?",
          options: [
            "A) Yalnızca performans için",
            "B) Middleware’lar eklendikleri sırayla yürütülür",
            "C) Sıra önemli değildir",
            "D) Yalnızca geliştirme ortamında etkilidir",
            "E) Statik dosyaları etkiler",
          ],
          correct: "B) Middleware’lar eklendikleri sırayla yürütülür",
          explanation:
            "Middleware’lar, Program.cs’de eklendikleri sırayla yürütülür; bu, isteğin işlenme sırasını belirler. Week 3 materyalinde (sayfa 27) bu vurgulanmıştır.",
        },
        {
          question: "LoggingMiddleware örneğinde hangi bağımlılık kullanılır?",
          options: [
            "A) HttpContext",
            "B) ILogger",
            "C) Controller",
            "D) Razor",
            "E) DbContext",
          ],
          correct: "B) ILogger",
          explanation:
            "LoggingMiddleware, günlüğe kaydetme için ILogger bağımlılığını kullanır. Week 3 materyalinde (sayfa 28) bu kod örneğinde gösterilmiştir.",
        },
        {
          question:
            "ASP.NET Core’da UseHttpsRedirection middleware’i ne yapar?",
          options: [
            "A) Statik dosyaları sunar",
            "B) HTTP isteklerini HTTPS’ye yönlendirir",
            "C) Kimlik doğrulama yapar",
            "D) Hata sayfalarını gösterir",
            "E) Uç noktaları eşler",
          ],
          correct: "B) HTTP isteklerini HTTPS’ye yönlendirir",
          explanation:
            "UseHttpsRedirection middleware’i, HTTP isteklerini HTTPS’ye yönlendirerek güvenliği artırır. Week 3 materyalinde (sayfa 26) bu işlev listelenmiştir.",
        },
        {
          question:
            "ASP.NET Core’da varsayılan Web API projesini test etmek için hangi araç kullanılır?",
          options: [
            "A) Visual Studio Code",
            "B) Swagger UI",
            "C) Postman",
            "D) SQL Server",
            "E) Git",
          ],
          correct: "B) Swagger UI",
          explanation:
            "Varsayılan ASP.NET Core Web API projesi, Swagger UI ile uç noktaları test etmek için yapılandırılmıştır. Week 3 materyalinde (sayfa 24) bu süreç açıklanmıştır.",
        },

        {
          question: "ASP.NET Core’da HTTP istekleri nasıl kapsüllenir?",
          options: [
            "A) IActionResult nesnesi ile",
            "B) HttpResponse nesnesi ile",
            "C) HttpRequest nesnesi ile",
            "D) RouteData nesnesi ile",
            "E) IQueryCollection ile",
          ],
          correct: "C) HttpRequest nesnesi ile",
          explanation:
            "ASP.NET Core’da gelen HTTP istekleri, tüm istek bilgilerini kapsülleyen HttpRequest nesnesi içinde saklanır. Week 5 materyalinde (sayfa 1), bu nesnenin rolü açıkça belirtilmiştir.",
        },
        {
          question: "HttpRequest nesnesinin temel işlevi nedir?",
          options: [
            "A) Yanıtları oluşturmak",
            "B) Gelen istek bilgilerine erişim sağlamak",
            "C) Rota parametrelerini otomatik bağlamak",
            "D) HTTP başlıklarını oluşturmak",
            "E) Yanıt durum kodlarını ayarlamak",
          ],
          correct: "B) Gelen istek bilgilerine erişim sağlamak",
          explanation:
            "HttpRequest nesnesi, gelen HTTP isteğiyle ilgili tüm bilgilere (metot, URL, başlıklar, gövde vb.) erişim sağlar. Week 5 materyalinde (sayfa 2), bu işlev detaylı bir şekilde açıklanmıştır.",
        },
        {
          question: "Denetleyicilerde HttpRequest nesnesine nasıl erişilir?",
          options: [
            "A) HttpContext.Request ile",
            "B) ControllerBase.Response ile",
            "C) RouteData.Values ile",
            "D) QueryCollection ile",
            "E) IActionResult ile",
          ],
          correct: "A) HttpContext.Request ile",
          explanation:
            "Denetleyicilerde HttpRequest nesnesine, ControllerBase sınıfının HttpContext.Request özelliği ile erişilir. Week 5 materyalinde (sayfa 2), bu erişim yöntemi örnekle gösterilmiştir.",
        },
        {
          question:
            "HttpRequest nesnesinden hangi özellik HTTP metodunu döndürür?",
          options: [
            "A) Path",
            "B) Method",
            "C) QueryString",
            "D) Scheme",
            "E) Headers",
          ],
          correct: "B) Method",
          explanation:
            "HttpRequest.Method özelliği, isteğin HTTP metodunu (GET, POST vb.) döndürür. Week 5 materyalinde (sayfa 2), bu özellik temel özellikler arasında listelenmiştir.",
        },
        {
          question: "Rota verilerine erişmek için hangi yöntem kullanılır?",
          options: [
            "A) HttpContext.GetRouteData()",
            "B) HttpRequest.Query",
            "C) HttpRequest.Headers",
            "D) HttpContext.Response",
            "E) IActionResult.Ok()",
          ],
          correct: "A) HttpContext.GetRouteData()",
          explanation:
            "Rota verilerine erişmek için HttpContext.GetRouteData() metodu kullanılır ve bu, RouteData nesnesini döndürür. Week 5 materyalinde (sayfa 4), bu yöntem örnekle açıklanmıştır.",
        },
        {
          question:
            "Sorgu parametreleri HttpRequest nesnesinde hangi özellik ile alınır?",
          options: [
            "A) RouteData",
            "B) Headers",
            "C) Query",
            "D) Body",
            "E) Method",
          ],
          correct: "C) Query",
          explanation:
            "Sorgu parametreleri, HttpRequest nesnesinin Query özelliği (IQueryCollection) ile alınır. Week 5 materyalinde (sayfa 5), bu özellik sorgu dizesi verilerine erişim için tanımlanmıştır.",
        },
        {
          question:
            "İstek başlıklarına erişmek için hangi HttpRequest özelliği kullanılır?",
          options: [
            "A) Query",
            "B) Headers",
            "C) RouteValues",
            "D) Scheme",
            "E) Path",
          ],
          correct: "B) Headers",
          explanation:
            "İstek başlıkları, HttpRequest.Headers özelliği (IHeaderDictionary) ile erişilir. Week 5 materyalinde (sayfa 7), bu özellik başlıklara erişim için açıklanmıştır.",
        },
        {
          question:
            "ASP.NET Core’da HTTP yanıtları hangi nesne ile oluşturulur?",
          options: [
            "A) HttpRequest",
            "B) HttpResponse",
            "C) RouteData",
            "D) IQueryCollection",
            "E) ModelState",
          ],
          correct: "B) HttpResponse",
          explanation:
            "HTTP yanıtları, HttpResponse nesnesi ile oluşturulur ve yönetilir. Week 5 materyalinde (sayfa 1), bu nesnenin yanıt oluşturmadaki rolü belirtilmiştir.",
        },
        {
          question:
            "Denetleyici eylemlerinden yanıt döndürmek için hangi arayüz kullanılır?",
          options: [
            "A) IHeaderDictionary",
            "B) IActionResult",
            "C) IQueryCollection",
            "D) HttpContext",
            "E) RouteData",
          ],
          correct: "B) IActionResult",
          explanation:
            "Denetleyici eylemlerinden farklı türde yanıtlar döndürmek için IActionResult arayüzü kullanılır. Week 5 materyalinde (sayfa 1), bu arayüzün önemi vurgulanmıştır.",
        },
        {
          question:
            "200 OK durum kodunu döndürmek için hangi IActionResult metodu kullanılır?",
          options: [
            "A) NotFound()",
            "B) BadRequest()",
            "C) Ok()",
            "D) StatusCode(500)",
            "E) CreatedAtAction()",
          ],
          correct: "C) Ok()",
          explanation:
            "Ok() metodu, 200 OK durum koduyla bir yanıt döndürür. Week 5 materyalinde (sayfa 3), bu metodun kullanımı örnekle gösterilmiştir.",
        },
        {
          question:
            "400 Bad Request durum kodunu döndürmek için hangi metod kullanılır?",
          options: [
            "A) Ok()",
            "B) BadRequest()",
            "C) NotFound()",
            "D) StatusCode(201)",
            "E) File()",
          ],
          correct: "B) BadRequest()",
          explanation:
            "BadRequest() metodu, 400 Bad Request durum koduyla bir yanıt döndürür. Week 5 materyalinde (sayfa 28), bu metodun kullanım amacı belirtilmiştir.",
        },
        {
          question: "Yanıt başlıkları hangi nesne ile ayarlanır?",
          options: [
            "A) HttpRequest.Headers",
            "B) HttpContext.Response.Headers",
            "C) RouteData.Values",
            "D) IActionResult.Headers",
            "E) QueryCollection",
          ],
          correct: "B) HttpContext.Response.Headers",
          explanation:
            "Yanıt başlıkları, HttpContext.Response.Headers ile ayarlanır. Week 5 materyalinde (sayfa 28), bu özellik yanıt başlıklarını yönetmek için açıklanmıştır.",
        },
        {
          question:
            "JSON formatında yanıt döndürmek için hangi IActionResult metodu kullanılır?",
          options: [
            "A) Content()",
            "B) File()",
            "C) Json()",
            "D) PhysicalFile()",
            "E) StatusCode()",
          ],
          correct: "C) Json()",
          explanation:
            "Json() metodu, JSON formatında bir yanıt döndürmek için kullanılır. Week 5 materyalinde (sayfa 28), bu metodun içerik türü ayarlama örneği verilmiştir.",
        },
        {
          question: "Model Bağlama’nın temel amacı nedir?",
          options: [
            "A) HTTP isteklerini yönlendirmek",
            "B) İstek verilerini manuel olarak çıkarmak",
            "C) İstek verilerini eylem parametrelerine otomatik eşlemek",
            "D) Yanıt başlıklarını ayarlamak",
            "E) Durum kodlarını değiştirmek",
          ],
          correct: "C) İstek verilerini eylem parametrelerine otomatik eşlemek",
          explanation:
            "Model Bağlama, gelen istek verilerini eylem metodu parametrelerine otomatik olarak eşler. Week 5 materyalinde (sayfa 18), bu temel amaç tanımlanmıştır.",
        },
        {
          question: "Model Bağlama hangi veri kaynağından bağlama yapamaz?",
          options: [
            "A) Rota Verileri",
            "B) Sorgu Dizeleri",
            "C) İstek Gövdesi",
            "D) İstek Başlıkları",
            "E) Veritabanı Kayıtları",
          ],
          correct: "E) Veritabanı Kayıtları",
          explanation:
            "Model Bağlama, rota verileri, sorgu dizeleri, istek gövdesi ve başlıklar gibi HTTP istek kaynaklarından veri bağlar, ancak veritabanı kayıtları bir bağlama kaynağı değildir. Week 5 materyalinde (sayfa 18), desteklenen kaynaklar listelenmiştir.",
        },
        {
          question: "Rota verilerinden bağlama nasıl gerçekleştirilir?",
          options: [
            "A) [FromBody] özniteliği ile",
            "B) Parametre adlarını rota parametreleriyle eşleştirerek",
            "C) HttpRequest.Query ile",
            "D) [FromHeader] özniteliği ile",
            "E) Manuel olarak RouteData ile",
          ],
          correct: "B) Parametre adlarını rota parametreleriyle eşleştirerek",
          explanation:
            "Rota verilerinden bağlama, eylem metodu parametre adlarının rota parametreleriyle eşleşmesiyle otomatik olarak yapılır. Week 5 materyalinde (sayfa 19), bu yöntem örnekle açıklanmıştır.",
        },
        {
          question:
            "Sorgu dizelerinden bağlama için hangi öznitelik gereklidir?",
          options: [
            "A) [FromBody]",
            "B) [FromHeader]",
            "C) [FromRoute]",
            "D) Hiçbiri",
            "E) [FromForm]",
          ],
          correct: "D) Hiçbiri",
          explanation:
            "Sorgu dizelerinden bağlama, özel bir özniteliğe ihtiyaç duymadan parametre adlarının sorgu parametreleriyle eşleşmesiyle otomatik gerçekleşir. Week 5 materyalinde (sayfa 20), bu durum belirtilmiştir.",
        },
        {
          question:
            "İstek gövdesinden veri bağlamak için hangi öznitelik kullanılır?",
          options: [
            "A) [FromRoute]",
            "B) [FromBody]",
            "C) [FromQuery]",
            "D) [FromHeader]",
            "E) [FromForm]",
          ],
          correct: "B) [FromBody]",
          explanation:
            "İstek gövdesinden (örn. JSON) veri bağlamak için [FromBody] özniteliği kullanılır. Week 5 materyalinde (sayfa 22), bu öznitelik örnekle tanıtılmıştır.",
        },
        {
          question:
            "İstek gövdesinden bağlama hangi HTTP metotlarıyla yaygın olarak kullanılır?",
          options: [
            "A) GET ve DELETE",
            "B) POST ve PUT",
            "C) HEAD ve OPTIONS",
            "D) TRACE ve PATCH",
            "E) GET ve POST",
          ],
          correct: "B) POST ve PUT",
          explanation:
            "İstek gövdesinden bağlama, gövde verisi gönderen POST ve PUT gibi metotlarla yaygın olarak kullanılır. Week 5 materyalinde (sayfa 22), bu kullanım belirtilmiştir.",
        },
        {
          question:
            "İstek başlıklarından bağlama için hangi öznitelik gereklidir?",
          options: [
            "A) [FromBody]",
            "B) [FromRoute]",
            "C) [FromHeader]",
            "D) [FromQuery]",
            "E) [FromForm]",
          ],
          correct: "C) [FromHeader]",
          explanation:
            "İstek başlıklarından veri bağlamak için [FromHeader] özniteliği kullanılır. Week 5 materyalinde (sayfa 24), bu öznitelik örnekle açıklanmıştır.",
        },
        {
          question: "[FromHeader] özniteliğinde Name özelliği neyi belirtir?",
          options: [
            "A) Parametre türünü",
            "B) Bağlanacak başlık adını",
            "C) Varsayılan değeri",
            "D) Rota parametresini",
            "E) İçerik türünü",
          ],
          correct: "B) Bağlanacak başlık adını",
          explanation:
            "[FromHeader] özniteliğinin Name özelliği, bağlanacak HTTP başlığının adını belirtir. Week 5 materyalinde (sayfa 24), bu özellik detaylandırılmıştır.",
        },
        {
          question:
            "Form verilerinden bağlama hangi HTTP metoduyla kullanılır?",
          options: ["A) GET", "B) POST", "C) DELETE", "D) PUT", "E) HEAD"],
          correct: "B) POST",
          explanation:
            "Form verilerinden bağlama, genellikle HTML form gönderimlerini işleyen POST metoduyla kullanılır. Week 5 materyalinde (sayfa 26), bu kullanım örneği verilmiştir.",
        },
        {
          question:
            "Form verilerinden bağlama için hangi öznitelik kullanılabilir?",
          options: [
            "A) [FromBody]",
            "B) [FromRoute]",
            "C) [FromForm]",
            "D) [FromHeader]",
            "E) [FromQuery]",
          ],
          correct: "C) [FromForm]",
          explanation:
            "Form verilerinden bağlama için [FromForm] özniteliği kullanılabilir, ancak basit durumlarda öznitelik olmadan da çalışır. Week 5 materyalinde (sayfa 26), bu durum açıklanmıştır.",
        },
        {
          question: "Model Bağlama’nın bir avantajı nedir?",
          options: [
            "A) Manuel veri ayrıştırmayı artırır",
            "B) Standart kodu azaltır",
            "C) Yanıt oluşturmayı karmaşıklaştırır",
            "D) HTTP metodlarını sınırlandırır",
            "E) Başlık yönetimini zorlaştırır",
          ],
          correct: "B) Standart kodu azaltır",
          explanation:
            "Model Bağlama, veri alımını ve dönüşümünü otomatikleştirerek standart kodu azaltır. Week 5 materyalinde (sayfa 18), bu fayda vurgulanmıştır.",
        },
        {
          question: "Model Bağlama başarısız olduğunda ne kontrol edilmelidir?",
          options: [
            "A) Parametre adlarının eşleşmesi",
            "B) Yanıt başlıkları",
            "C) HTTP metot sırası",
            "D) Rota şablonları",
            "E) Veritabanı bağlantısı",
          ],
          correct: "A) Parametre adlarının eşleşmesi",
          explanation:
            "Model Bağlama başarısız olduğunda, parametre adlarının bağlama kaynağıyla (rota, sorgu vb.) eşleştiği kontrol edilmelidir. Week 5 materyalinde (sayfa 28), bu sorun giderme adımı belirtilmiştir.",
        },
        {
          question: "JSON gövdesinden bağlama için hangi başlık önemlidir?",
          options: [
            "A) User-Agent",
            "B) Accept-Language",
            "C) Content-Type",
            "D) Authorization",
            "E) Host",
          ],
          correct: "C) Content-Type",
          explanation:
            "JSON gövdesinden bağlama için Content-Type başlığı (örn. application/json) önemlidir, çünkü doğru biçimlendiriciyi seçer. Week 5 materyalinde (sayfa 28), bu gereklilik belirtilmiştir.",
        },
        {
          question:
            "Hangi IActionResult metodu dosya döndürmek için kullanılır?",
          options: [
            "A) Json()",
            "B) Content()",
            "C) File()",
            "D) Ok()",
            "E) BadRequest()",
          ],
          correct: "C) File()",
          explanation:
            "File() metodu, fiziksel bir dosyayı veya bayt dizisini istemciye döndürmek için kullanılır. Week 5 materyalinde (sayfa 28), bu metodun kullanımı açıklanmıştır.",
        },
        {
          question:
            "201 Created durum kodunu döndürmek için hangi metod kullanılır?",
          options: [
            "A) Ok()",
            "B) CreatedAtAction()",
            "C) NotFound()",
            "D) StatusCode(400)",
            "E) Content()",
          ],
          correct: "B) CreatedAtAction()",
          explanation:
            "CreatedAtAction() metodu, 201 Created durum koduyla yeni oluşturulan bir kaynağın yerini döndürür. Week 5 materyalinde (sayfa 28), bu metodun amacı belirtilmiştir.",
        },
        {
          question: "Model Bağlama’da tür dönüşümü neyi ifade eder?",
          options: [
            "A) Yanıtların JSON’a çevrilmesi",
            "B) İstek dizesinden .NET türlerine otomatik dönüşüm",
            "C) Başlıkların kodlanması",
            "D) Rota verilerinin şifrelenmesi",
            "E) HTTP metodunun değişimi",
          ],
          correct: "B) İstek dizesinden .NET türlerine otomatik dönüşüm",
          explanation:
            "Model Bağlama, istekteki dize değerlerini .NET türlerine (örn. string -> int) otomatik olarak dönüştürür. Week 5 materyalinde (sayfa 18), bu özellik tanımlanmıştır.",
        },
        {
          question: "Hangi durumda ModelState.IsValid kontrol edilmelidir?",
          options: [
            "A) Rota verileri bağlanırken",
            "B) Doğrulama etkinse",
            "C) Yanıt başlıkları ayarlanırken",
            "D) HTTP metotları değiştiğinde",
            "E) Sorgu parametreleri alınırken",
          ],
          correct: "B) Doğrulama etkinse",
          explanation:
            "Model doğrulama etkinse, ModelState.IsValid ile doğrulama hataları kontrol edilmelidir. Week 5 materyalinde (sayfa 28), bu sorun giderme adımı önerilmiştir.",
        },

        {
          question: "Veri doğrulama neden önemlidir?",
          options: [
            "A) Yanıt sürelerini hızlandırmak için",
            "B) Veri bütünlüğünü, güvenliği ve kullanıcı deneyimini sağlamak için",
            "C) HTTP metotlarını tanımlamak için",
            "D) API uç noktalarını gizlemek için",
            "E) Kaynak kullanımını artırmak için",
          ],
          correct:
            "B) Veri bütünlüğünü, güvenliği ve kullanıcı deneyimini sağlamak için",
          explanation:
            "Veri doğrulama, veri bütünlüğünü korur, güvenlik açıklarını önler ve kullanıcıya bilgilendirici hata mesajları sunarak deneyimi iyileştirir. Week 6 materyalinde (sayfa 2), bu nedenler detaylı bir şekilde açıklanmıştır.",
        },
        {
          question:
            "ASP.NET Core’da veri doğrulama için en yaygın deklaratif yöntem nedir?",
          options: [
            "A) ModelState.IsValid",
            "B) Veri Notasyon Özellikleri",
            "C) IValidatableObject",
            "D) FluentValidation",
            "E) Özel Doğrulama Özellikleri",
          ],
          correct: "B) Veri Notasyon Özellikleri",
          explanation:
            "Veri Notasyon Özellikleri, modellerde doğrulama kurallarını deklaratif olarak tanımlamanın en yaygın yoludur. Week 6 materyalinde (sayfa 4), bu yöntemin kullanımı örneklerle tanıtılmıştır.",
        },
        {
          question:
            "Hangi Veri Notasyon Özelliği bir alanın zorunlu olduğunu belirtir?",
          options: [
            "A) [Range]",
            "B) [StringLength]",
            "C) [Required]",
            "D) [EmailAddress]",
            "E) [Compare]",
          ],
          correct: "C) [Required]",
          explanation:
            "[Required] özniteliği, bir özelliğin boş olamayacağını belirtir. Week 6 materyalinde (sayfa 4), bu öznitelik yaygın kullanılan özellikler arasında listelenmiştir.",
        },
        {
          question: "Model Durumu Doğrulama hangi aşamada tetiklenir?",
          options: [
            "A) Yanıt oluşturulurken",
            "B) Model bağlama sırasında",
            "C) HTTP isteği gönderilmeden önce",
            "D) Denetleyici eylemi tamamlandıktan sonra",
            "E) URI tasarımı sırasında",
          ],
          correct: "B) Model bağlama sırasında",
          explanation:
            "Model Durumu Doğrulama, model bağlama sırasında otomatik olarak tetiklenir ve doğrulama sonuçları ModelState’e kaydedilir. Week 6 materyalinde (sayfa 6), bu süreç açıklanmıştır.",
        },
        {
          question:
            "Denetleyicide doğrulama hatalarını kontrol etmek için hangi özellik kullanılır?",
          options: [
            "A) ModelState.IsValid",
            "B) HttpContext.Request",
            "C) IActionResult.Json",
            "D) ValidationContext",
            "E) RouteData.Values",
          ],
          correct: "A) ModelState.IsValid",
          explanation:
            "ModelState.IsValid, doğrulamanın başarılı olup olmadığını kontrol etmek için kullanılır. Week 6 materyalinde (sayfa 7), bu özelliğin kullanımı örnekle gösterilmiştir.",
        },
        {
          question: "Hangi durumda BadRequest(ModelState) yanıtı döndürülür?",
          options: [
            "A) Doğrulama başarılı olduğunda",
            "B) ModelState.IsValid false olduğunda",
            "C) URI tasarımı hatalı olduğunda",
            "D) HTTP metodu yanlış kullanıldığında",
            "E) JSON yanıtı oluşturulurken",
          ],
          correct: "B) ModelState.IsValid false olduğunda",
          explanation:
            "ModelState.IsValid false ise, doğrulama hataları vardır ve BadRequest(ModelState) ile 400 durumu döndürülür. Week 6 materyalinde (sayfa 7), bu kullanım açıklanmıştır.",
        },
        {
          question:
            "Karmaşık doğrulama senaryoları için hangi arayüz kullanılır?",
          options: [
            "A) IActionResult",
            "B) IValidatableObject",
            "C) IHeaderDictionary",
            "D) IQueryCollection",
            "E) ValidationAttribute",
          ],
          correct: "B) IValidatableObject",
          explanation:
            "IValidatableObject arayüzü, karmaşık doğrulama mantığını modele eklemek için kullanılır. Week 6 materyalinde (sayfa 10), bu arayüzün uygulaması örneklendirilmiştir.",
        },
        {
          question: "IValidatableObject’ta Validate yöntemi ne döndürür?",
          options: [
            "A) IActionResult",
            "B) bool",
            "C) IEnumerable<ValidationResult>",
            "D) string",
            "E) ModelStateDictionary",
          ],
          correct: "C) IEnumerable<ValidationResult>",
          explanation:
            "Validate yöntemi, doğrulama hatalarını temsil eden ValidationResult nesnelerini içeren bir koleksiyon döndürür. Week 6 materyalinde (sayfa 10), bu yapı detaylandırılmıştır.",
        },
        {
          question:
            "Özel Doğrulama Özellikleri oluşturmak için hangi sınıftan miras alınır?",
          options: [
            "A) ControllerBase",
            "B) ValidationAttribute",
            "C) ModelState",
            "D) AbstractValidator",
            "E) HttpRequest",
          ],
          correct: "B) ValidationAttribute",
          explanation:
            "Özel Doğrulama Özellikleri, ValidationAttribute sınıfından miras alınarak oluşturulur. Week 6 materyalinde (sayfa 12), bu yöntem örnekle açıklanmıştır.",
        },
        {
          question: "FluentValidation hangi tür projelerde tercih edilir?",
          options: [
            "A) Basit doğrulama gerektiren projelerde",
            "B) Karmaşık doğrulama mantığı gerektiren projelerde",
            "C) URI tasarımı odaklı projelerde",
            "D) HTTP metot testi yapılan projelerde",
            "E) JSON biçimlendirme gerektiren projelerde",
          ],
          correct: "B) Karmaşık doğrulama mantığı gerektiren projelerde",
          explanation:
            "FluentValidation, karmaşık doğrulama ihtiyaçları için etkileyici bir yol sunar. Week 6 materyalinde (sayfa 3), bu durum belirtilmiştir.",
        },
        {
          question: "API Tasarım Desenlerinin temel amacı nedir?",
          options: [
            "A) Veri doğrulama kurallarını tanımlamak",
            "B) Kullanıcı dostu, sürdürülebilir ve ölçeklenebilir API’ler oluşturmak",
            "C) HTTP isteklerini hızlandırmak",
            "D) Model bağlamayı otomatikleştirmek",
            "E) Güvenlik açıklarını kapatmak",
          ],
          correct:
            "B) Kullanıcı dostu, sürdürülebilir ve ölçeklenebilir API’ler oluşturmak",
          explanation:
            "API Tasarım Desenleri, kullanım kolaylığı, sürdürülebilirlik ve ölçeklenebilirlik sağlar. Week 6 materyalinde (sayfa 15), bu amaç vurgulanmıştır.",
        },
        {
          question: "Kaynak Odaklı Tasarım’da kaynaklar nasıl temsil edilir?",
          options: [
            "A) Fiillerle",
            "B) İsimlerle",
            "C) Sorgu parametreleriyle",
            "D) HTTP başlıklarıyla",
            "E) JSON gövdeleriyle",
          ],
          correct: "B) İsimlerle",
          explanation:
            "Kaynak Odaklı Tasarım’da kaynaklar, genellikle çoğul isimler olarak temsil edilir (örn. /products). Week 6 materyalinde (sayfa 16), bu ilke açıklanmıştır.",
        },
        {
          question: "Hangi HTTP metodu bir kaynağı almak için kullanılır?",
          options: ["A) POST", "B) PUT", "C) GET", "D) DELETE", "E) PATCH"],
          correct: "C) GET",
          explanation:
            "GET metodu, bir kaynağı veya kaynak listesini almak için kullanılır ve güvenli/idempotenttir. Week 6 materyalinde (sayfa 16), bu kullanım tanımlanmıştır.",
        },
        {
          question: "URI tasarımlarında eylemler nasıl belirtilmelidir?",
          options: [
            "A) URI yolunda fiillerle",
            "B) HTTP metotlarıyla",
            "C) Sorgu parametreleriyle",
            "D) İstek gövdesinde",
            "E) Başlıklarda",
          ],
          correct: "B) HTTP metotlarıyla",
          explanation:
            "URI’lerde eylemler fiillerle değil, HTTP metotlarıyla (GET, POST vb.) belirtilir. Week 6 materyalinde (sayfa 17), bu kural açıklanmıştır.",
        },
        {
          question:
            "URI’lerde kelimeleri ayırmak için hangi karakter önerilir?",
          options: [
            "A) Boşluk",
            "B) Alt çizgi (_)",
            "C) Tire (-)",
            "D) Nokta (.)",
            "E) Büyük harf",
          ],
          correct: "C) Tire (-)",
          explanation:
            "URI’lerde okunabilirlik için tire (-) kullanımı önerilir (örn. /customer-orders). Week 6 materyalinde (sayfa 17), bu en iyi uygulama belirtilmiştir.",
        },
        {
          question: "Hangi HTTP metodu yeni bir kaynak oluşturur?",
          options: ["A) GET", "B) POST", "C) PUT", "D) PATCH", "E) DELETE"],
          correct: "B) POST",
          explanation:
            "POST metodu, yeni bir kaynak oluşturmak için kullanılır ve idempotent değildir. Week 6 materyalinde (sayfa 18), bu semantik anlam açıklanmıştır.",
        },
        {
          question: "PUT metodunun temel özelliği nedir?",
          options: [
            "A) Kısmi güncelleme yapar",
            "B) Idempotenttir",
            "C) Güvenli bir metottur",
            "D) Koleksiyonları sıralar",
            "E) Hipermedya bağlantıları ekler",
          ],
          correct: "B) Idempotenttir",
          explanation:
            "PUT, bir kaynağı tamamen günceller ve idempotenttir; aynı istek birden çok kez aynı sonucu üretir. Week 6 materyalinde (sayfa 18), bu özellik tanımlanmıştır.",
        },
        {
          question: "JSON’un API’lerde tercih edilme nedeni nedir?",
          options: [
            "A) Daha hızlı doğrulama sağlar",
            "B) İnsan tarafından okunabilir ve hafiftir",
            "C) URI tasarımını kolaylaştırır",
            "D) HTTP metotlarını standartlaştırır",
            "E) Model bağlamayı otomatikleştirir",
          ],
          correct: "B) İnsan tarafından okunabilir ve hafiftir",
          explanation:
            "JSON, okunabilirliği ve hafif yapısıyla API’lerde tercih edilir. Week 6 materyalinde (sayfa 19), bu avantajlar listelenmiştir.",
        },
        {
          question: "HATEOAS’ın temel amacı nedir?",
          options: [
            "A) Veri doğrulamayı otomatikleştirmek",
            "B) API keşfedilebilirliğini ve navigasyonu geliştirmek",
            "C) Kaynakları sıralamak",
            "D) HTTP metotlarını değiştirmek",
            "E) JSON yanıtlarını küçültmek",
          ],
          correct: "B) API keşfedilebilirliğini ve navigasyonu geliştirmek",
          explanation:
            "HATEOAS, hipermedya bağlantılarıyla API’nin keşfedilebilirliğini ve istemci navigasyonunu iyileştirir. Week 6 materyalinde (sayfa 21), bu kavram detaylandırılmıştır.",
        },
        {
          question: "HATEOAS yanıtlarında hangi bölüm bağlantıları içerir?",
          options: [
            "A) pageInfo",
            "B) _links",
            "C) items",
            "D) headers",
            "E) errors",
          ],
          correct: "B) _links",
          explanation:
            "HATEOAS yanıtlarında bağlantılar genellikle '_links' bölümünde yer alır. Week 6 materyalinde (sayfa 21), bu yapı örnekle gösterilmiştir.",
        },
        {
          question: "Sayfalama neden gereklidir?",
          options: [
            "A) Veri doğrulamayı kolaylaştırmak için",
            "B) Büyük kaynak koleksiyonlarını verimli işlemek için",
            "C) HTTP metotlarını standartlaştırmak için",
            "D) URI hiyerarşisini basitleştirmek için",
            "E) JSON yanıtlarını optimize etmek için",
          ],
          correct: "B) Büyük kaynak koleksiyonlarını verimli işlemek için",
          explanation:
            "Sayfalama, büyük veri kümelerini yönetilebilir parçalara böler ve performansı artırır. Week 6 materyalinde (sayfa 22), bu fayda belirtilmiştir.",
        },
        {
          question: "Sayfalama meta verilerinde hangi bilgi yer almaz?",
          options: [
            "A) Geçerli sayfa numarası",
            "B) Sayfa boyutu",
            "C) Toplam öğe sayısı",
            "D) Doğrulama hataları",
            "E) Toplam sayfa sayısı",
          ],
          correct: "D) Doğrulama hataları",
          explanation:
            "Sayfalama meta verileri, sayfa numarası, boyutu, toplam öğe ve sayfa sayısı gibi bilgileri içerir; doğrulama hataları ise ModelState ile ilişkilidir. Week 6 materyalinde (sayfa 23), bu yapı örneklendirilmiştir.",
        },
        {
          question: "Filtreleme için hangi mekanizma kullanılır?",
          options: [
            "A) HTTP metotları",
            "B) Sorgu parametreleri",
            "C) Rota verileri",
            "D) İstek gövdesi",
            "E) URI hiyerarşisi",
          ],
          correct: "B) Sorgu parametreleri",
          explanation:
            "Filtreleme, sorgu parametreleriyle yapılır (örn. /products?category=electronics). Week 6 materyalinde (sayfa 24), bu yöntem açıklanmıştır.",
        },
        {
          question:
            "Sıralama düzenini belirtmek için hangi parametre kullanılır?",
          options: [
            "A) pageSize",
            "B) sortOrder",
            "C) filterBy",
            "D) rel",
            "E) href",
          ],
          correct: "B) sortOrder",
          explanation:
            "Sıralama düzeni, 'sortOrder' parametresiyle (asc/desc) belirtilir. Week 6 materyalinde (sayfa 25), bu kullanım örneği verilmiştir.",
        },
        {
          question: "Hangi HTTP metodu bir kaynağı kısmen günceller?",
          options: ["A) GET", "B) POST", "C) PUT", "D) PATCH", "E) DELETE"],
          correct: "D) PATCH",
          explanation:
            "PATCH metodu, bir kaynağı kısmen güncellemek için kullanılır ve idempotent olmayabilir. Week 6 materyalinde (sayfa 18), bu semantik anlam tanımlanmıştır.",
        },
        {
          question: "DELETE metodunun özelliği nedir?",
          options: [
            "A) Güvenlidir",
            "B) Idempotenttir",
            "C) Kısmi güncelleme yapar",
            "D) Yeni kaynak oluşturur",
            "E) Koleksiyonları filtreler",
          ],
          correct: "B) Idempotenttir",
          explanation:
            "DELETE, bir kaynağı siler ve idempotenttir; birden çok kez çağrılması aynı sonucu üretir. Week 6 materyalinde (sayfa 19), bu özellik belirtilmiştir.",
        },
        {
          question: "Hangi araç API testinde kullanılır?",
          options: [
            "A) FluentValidation",
            "B) Postman",
            "C) ModelState",
            "D) ValidationAttribute",
            "E) IValidatableObject",
          ],
          correct: "B) Postman",
          explanation:
            "Postman, API uç noktalarını test etmek için kullanılan bir araçtır. Week 6 materyalinde (sayfa 15), bu araç önerilmiştir.",
        },
        {
          question: "HATEOAS bağlantılarında 'rel' neyi ifade eder?",
          options: [
            "A) Bağlantının URI’sini",
            "B) HTTP metodunu",
            "C) Bağlantının ilişkisini",
            "D) Sayfa numarasını",
            "E) Doğrulama hatasını",
          ],
          correct: "C) Bağlantının ilişkisini",
          explanation:
            "'rel', bağlantının mevcut kaynakla ilişkisini (örn. 'self', 'update') belirtir. Week 6 materyalinde (sayfa 21), bu yapı örneklendirilmiştir.",
        },
        {
          question: "URI’lerde hangi durumdan kaçınılmalıdır?",
          options: [
            "A) Tire kullanımı",
            "B) Küçük harf kullanımı",
            "C) Sondaki slaşlar",
            "D) Çoğul isimler",
            "E) Hiyerarşik yollar",
          ],
          correct: "C) Sondaki slaşlar",
          explanation:
            "URI’lerde sondaki slaşlardan kaçınılması önerilir (örn. /products yerine /products/). Week 6 materyalinde (sayfa 17), bu kural belirtilmiştir.",
        },
        {
          question: "Filtreleme ve sıralama birleştirildiğinde ne sağlanır?",
          options: [
            "A) Özelleştirilmiş kaynak alt kümeleri",
            "B) Daha hızlı doğrulama",
            "C) HTTP metodlarının değişimi",
            "D) URI hiyerarşisinin sadeleşmesi",
            "E) Hipermedya bağlantılarının azalması",
          ],
          correct: "A) Özelleştirilmiş kaynak alt kümeleri",
          explanation:
            "Filtreleme ve sıralama birleştiğinde, istemciler özelleştirilmiş veri alt kümeleri alabilir. Week 6 materyalinde (sayfa 25), bu fayda örneklendirilmiştir.",
        },

        {
          question: "Bağımlılık Enjeksiyonu (DI) nedir?",
          options: [
            "A) Bir programlama dili",
            "B) Bileşenlerin bağımlılıklarını kendilerinin oluşturduğu bir yöntem",
            "C) Bağımlılıkların bileşenlere dışarıdan enjekte edildiği bir tasarım deseni",
            "D) Yalnızca veritabanı yönetimini kolaylaştıran bir araç",
            "E) HTTP isteklerini yönlendiren bir mekanizma",
          ],
          correct:
            "C) Bağımlılıkların bileşenlere dışarıdan enjekte edildiği bir tasarım deseni",
          explanation:
            "Bağımlılık Enjeksiyonu (DI), bileşenlerin bağımlılıklarını kendilerinin oluşturması yerine dışarıdan enjekte edilmesiyle bağımlılıkları yöneten bir tasarım desenidir. Week 4 materyalinde (sayfa 1), bu tanım açıkça belirtilmiştir.",
        },
        {
          question: "Kontrolün Tersine Çevrilmesi (IoC) neyi ifade eder?",
          options: [
            "A) Uygulama kodunun nesne oluşturmayı kontrol ettiği bir yöntem",
            "B) Nesne oluşturma ve yaşam döngüsünün bir çerçeve tarafından yönetildiği bir prensip",
            "C) Yalnızca yönlendirme işlemlerini tersine çeviren bir teknik",
            "D) Bağımlılıkların tamamen ortadan kaldırıldığı bir yaklaşım",
            "E) HTTP metodlarının sırasını değiştiren bir yapı",
          ],
          correct:
            "B) Nesne oluşturma ve yaşam döngüsünün bir çerçeve tarafından yönetildiği bir prensip",
          explanation:
            "Kontrolün Tersine Çevrilmesi (IoC), nesne oluşturma ve yaşam döngüsü kontrolünün uygulama kodundan çerçeveye tersine çevrildiği bir prensiptir. Week 4 materyalinde (sayfa 2), IoC’nin bu şekilde açıklandığı görülmektedir.",
        },
        {
          question:
            "Bağımlılık Enjeksiyonu’nun temel faydalarından biri nedir?",
          options: [
            "A) Kodun daha karmaşık hale gelmesi",
            "B) Gevşek bağlılık sağlayarak esnekliği artırması",
            "C) Test edilebilirliği azaltması",
            "D) Bileşenler arası sıkı bağımlılığı teşvik etmesi",
            "E) Yalnızca performansı artırması",
          ],
          correct: "B) Gevşek bağlılık sağlayarak esnekliği artırması",
          explanation:
            "DI, bileşenler arası sıkı bağımlılığı azaltarak gevşek bağlılık sağlar ve sistemi daha esnek hale getirir. Week 4 materyalinde (sayfa 3), bu fayda ‘Gevşek Bağlılık’ başlığı altında listelenmiştir.",
        },
        {
          question: "ASP.NET Core’daki DI Konteyneri’nin temel işlevi nedir?",
          options: [
            "A) Yalnızca HTTP isteklerini yönlendirmek",
            "B) Servislerin oluşturulmasını ve yaşam döngüsünü yönetmek",
            "C) Statik dosyaları sunmak",
            "D) Veritabanı bağlantılarını oluşturmak",
            "E) URL’leri dinamik olarak oluşturmak",
          ],
          correct: "B) Servislerin oluşturulmasını ve yaşam döngüsünü yönetmek",
          explanation:
            "ASP.NET Core’un yerleşik DI Konteyneri, servislerin oluşturulmasını ve yaşam döngüsünü yönetir. Week 4 materyalinde (sayfa 3), bu rol açıkça tanımlanmıştır.",
        },
        {
          question:
            "Servislerin DI Konteynerine kaydedilmesi hangi dosyada yapılır?",
          options: [
            "A) Startup.cs",
            "B) Program.cs",
            "C) appsettings.json",
            "D) Controller.cs",
            "E) Middleware.cs",
          ],
          correct: "B) Program.cs",
          explanation:
            "ASP.NET Core’da servis kaydı, Program.cs dosyasında builder.Services koleksiyonu aracılığıyla yapılır. Week 4 materyalinde (sayfa 4), bu süreç örnekle açıklanmıştır.",
        },
        {
          question:
            "AddTransient metodu ile kaydedilen bir servis ne zaman yeni bir örnek oluşturur?",
          options: [
            "A) Uygulama yaşam döngüsü boyunca bir kez",
            "B) Her HTTP isteği için bir kez",
            "C) Her istendiğinde",
            "D) Yalnızca ilk istekte",
            "E) Kapsam değiştiğinde",
          ],
          correct: "C) Her istendiğinde",
          explanation:
            "Transient servisler, DI Konteynerinden her istendiğinde yeni bir örnek oluşturur. Week 4 materyalinde (sayfa 5), bu özellik ‘Transient Servis Yaşam Döngüsü’ başlığı altında belirtilmiştir.",
        },
        {
          question: "Scoped servislerin temel özelliği nedir?",
          options: [
            "A) Uygulama genelinde tek bir örnek paylaşılır",
            "B) Her istendiğinde yeni bir örnek oluşturulur",
            "C) HTTP isteği başına bir örnek oluşturulur ve istek içinde paylaşılır",
            "D) Durumu olmayan işlemler için kullanılır",
            "E) Yalnızca test amaçlıdır",
          ],
          correct:
            "C) HTTP isteği başına bir örnek oluşturulur ve istek içinde paylaşılır",
          explanation:
            "Scoped servisler, HTTP isteği başına bir kez oluşturulur ve o istek içinde paylaşılır. Week 4 materyalinde (sayfa 7), bu davranış açıkça tanımlanmıştır.",
        },
        {
          question: "Singleton servisler hangi durumda uygundur?",
          options: [
            "A) Her istekte yeni bir örnek gerektiğinde",
            "B) Uygulama genelinde paylaşılan durumu yönetmek için",
            "C) HTTP isteği içinde durum korumak için",
            "D) Hafif ve geçici işlemler için",
            "E) Test edilebilirliği artırmak için",
          ],
          correct: "B) Uygulama genelinde paylaşılan durumu yönetmek için",
          explanation:
            "Singleton servisler, uygulama yaşam döngüsü boyunca tek bir örnek oluşturur ve paylaşılan durum veya pahalı oluşturmalar için uygundur. Week 4 materyalinde (sayfa 9), bu kullanım durumu belirtilmiştir.",
        },
        {
          question: "Yapıcı Enjeksiyonu nasıl çalışır?",
          options: [
            "A) Bağımlılıklar metot parametreleri ile sağlanır",
            "B) Bağımlılıklar sınıfın özelliklerine atanır",
            "C) Bağımlılıklar yapıcının parametreleri aracılığıyla sağlanır",
            "D) Bağımlılıklar yalnızca singleton olarak kaydedilir",
            "E) Bağımlılıklar manuel olarak çözümlenir",
          ],
          correct:
            "C) Bağımlılıklar yapıcının parametreleri aracılığıyla sağlanır",
          explanation:
            "Yapıcı Enjeksiyonu, bağımlılıkların bir sınıfın yapıcısına parametre olarak enjekte edilmesiyle çalışır. Week 4 materyalinde (sayfa 13), bu yöntem detaylı bir örnekle açıklanmıştır.",
        },
        {
          question: "Metot Enjeksiyonu hangi öznitelikle kullanılır?",
          options: [
            "A) [Route]",
            "B) [FromServices]",
            "C) [HttpGet]",
            "D) [Inject]",
            "E) [Bind]",
          ],
          correct: "B) [FromServices]",
          explanation:
            "Metot Enjeksiyonu, bağımlılıkların metot parametrelerine enjekte edilmesi için [FromServices] özniteliğiyle kullanılır. Week 4 materyalinde (sayfa 15), bu kullanım örneğiyle gösterilmiştir.",
        },
        {
          question: "Özellik Enjeksiyonu neden ASP.NET Core’da tercih edilmez?",
          options: [
            "A) Bağımlılıkları açıkça gösterir",
            "B) Test edilebilirliği artırır",
            "C) Bağımlılıkları gizler ve değiştirilebilirliği teşvik eder",
            "D) Performansı artırır",
            "E) Daha az kod gerektirir",
          ],
          correct:
            "C) Bağımlılıkları gizler ve değiştirilebilirliği teşvik eder",
          explanation:
            "Özellik Enjeksiyonu, bağımlılıkları yapıcının dışında gizler ve değişmezliği azaltır, bu yüzden Yapıcı Enjeksiyonu tercih edilir. Week 4 materyalinde (sayfa 17), bu dezavantajlar belirtilmiştir.",
        },
        {
          question:
            "Bağımlılıklar için arayüz kullanmanın temel avantajı nedir?",
          options: [
            "A) Kodun daha hızlı çalışmasını sağlar",
            "B) Gevşek bağlılık ve esneklik sağlar",
            "C) Bağımlılıkların sayısını artırır",
            "D) Test edilebilirliği azaltır",
            "E) Yalnızca performansı optimize eder",
          ],
          correct: "B) Gevşek bağlılık ve esneklik sağlar",
          explanation:
            "Arayüzler, somut sınıflar yerine soyutlamalara bağımlılık sağlayarak gevşek bağlılık ve esneklik sunar. Week 4 materyalinde (sayfa 18), bu fayda vurgulanmıştır.",
        },
        {
          question: "ASP.NET Core’da yönlendirme neyi ifade eder?",
          options: [
            "A) Bağımlılıkların enjekte edilmesi",
            "B) HTTP isteklerinin uygun uç noktalara eşlenmesi",
            "C) Servislerin yaşam döngüsünün yönetilmesi",
            "D) Statik dosyaların sunulması",
            "E) Veritabanı işlemlerinin düzenlenmesi",
          ],
          correct: "B) HTTP isteklerinin uygun uç noktalara eşlenmesi",
          explanation:
            "Yönlendirme, gelen HTTP isteklerini uygulama içindeki uygun uç noktalara eşler. Week 4 materyalinde (sayfa 21), bu tanım açıkça verilmiştir.",
        },
        {
          question: "Geleneksel Yönlendirme nerede tanımlanır?",
          options: [
            "A) Kontrolcüler üzerinde özniteliklerle",
            "B) Program.cs içinde UseEndpoints ara yazılımında",
            "C) appsettings.json dosyasında",
            "D) Middleware sınıflarında",
            "E) Servis kayıtlarında",
          ],
          correct: "B) Program.cs içinde UseEndpoints ara yazılımında",
          explanation:
            "Geleneksel Yönlendirme, Program.cs’de UseEndpoints ara yazılımı içinde merkezi olarak tanımlanır. Week 4 materyalinde (sayfa 22), bu yapılandırma örneğiyle gösterilmiştir.",
        },
        {
          question: "Öznitelik Yönlendirmesi’nin avantajı nedir?",
          options: [
            "A) Daha az esneklik sağlar",
            "B) Rotaları kontrolcü ve eylemler üzerinde tanımlayarak daha fazla kontrol sunar",
            "C) Yalnızca basit uygulamalar için uygundur",
            "D) URL yapısını merkezi olarak zorlar",
            "E) Performansı düşürür",
          ],
          correct:
            "B) Rotaları kontrolcü ve eylemler üzerinde tanımlayarak daha fazla kontrol sunar",
          explanation:
            "Öznitelik Yönlendirmesi, rotaları kontrolcü ve eylemler üzerinde özniteliklerle tanımlayarak esneklik ve kontrol sağlar. Week 4 materyalinde (sayfa 25), bu avantaj belirtilmiştir.",
        },
        {
          question: "Geleneksel Yönlendirme’de varsayılan rota deseni nedir?",
          options: [
            "A) {controller}/{action}/{id?}",
            "B) api/[controller]/{id}",
            "C) {action}/{controller}/{id}",
            "D) {id}/{controller}/{action}",
            "E) [controller]/{action}",
          ],
          correct: "A) {controller}/{action}/{id?}",
          explanation:
            "Geleneksel Yönlendirme’de varsayılan rota deseni {controller}/{action}/{id?} şeklindedir. Week 4 materyalinde (sayfa 23), bu desen açıklanmıştır.",
        },
        {
          question:
            "Öznitelik Yönlendirmesi’nde [HttpGet] özniteliği neyi belirtir?",
          options: [
            "A) POST isteklerini eşler",
            "B) GET isteklerini eşler",
            "C) DELETE isteklerini eşler",
            "D) Tüm HTTP metotlarını eşler",
            "E) Yönlendirme parametrelerini kısıtlar",
          ],
          correct: "B) GET isteklerini eşler",
          explanation:
            "[HttpGet] özniteliği, GET isteklerini belirli bir eylemle eşlemek için kullanılır. Week 4 materyalinde (sayfa 25), bu öznitelik tanıtılmıştır.",
        },
        {
          question: "Rota parametreleri nasıl tanımlanır?",
          options: [
            "A) Köşeli parantezler ile []",
            "B) Kıvırcık parantezler ile {}",
            "C) Parantezler ile ()",
            "D) Çift tırnak ile “”",
            "E) Tek tırnak ile ‘’",
          ],
          correct: "B) Kıvırcık parantezler ile {}",
          explanation:
            "Rota parametreleri, rota şablonlarında kıvırcık parantezler ({}) içinde tanımlanır, örneğin {id}. Week 4 materyalinde (sayfa 27), bu kullanım gösterilmiştir.",
        },
        {
          question: "Rota kısıtlamalarının amacı nedir?",
          options: [
            "A) URL’lerin uzunluğunu artırmak",
            "B) Rota parametrelerinin eşleşmesini belirli tiplerle kısıtlamak",
            "C) Yönlendirme hızını artırmak",
            "D) Bağımlılıkları enjekte etmek",
            "E) HTTP metotlarını değiştirmek",
          ],
          correct:
            "B) Rota parametrelerinin eşleşmesini belirli tiplerle kısıtlamak",
          explanation:
            "Rota kısıtlamaları, parametrelerin belirli tiplere (örneğin, int) uygun olmasını sağlar. Week 4 materyalinde (sayfa 28), bu amaç açıklanmıştır.",
        },
        {
          question:
            "Aşağıdaki rota kısıtlamalarından hangisi bir parametrenin tamsayı olmasını sağlar?",
          options: [
            "A) {id:guid}",
            "B) {id:bool}",
            "C) {id:int}",
            "D) {id:regex}",
            "E) {id:datetime}",
          ],
          correct: "C) {id:int}",
          explanation:
            "{id:int} kısıtlaması, id parametresinin tamsayı olmasını sağlar. Week 4 materyalinde (sayfa 28), yaygın kısıtlamalar listelenmiştir.",
        },
        {
          question:
            "Rota şablonlarında isteğe bağlı parametre nasıl belirtilir?",
          options: [
            "A) Parametre adından sonra ! ile",
            "B) Parametre adından sonra ? ile",
            "C) Parametre adından sonra * ile",
            "D) Parametre adından sonra & ile",
            "E) Parametre adından sonra = ile",
          ],
          correct: "B) Parametre adından sonra ? ile",
          explanation:
            "İsteğe bağlı parametreler, rota şablonunda parametre adından sonra ? ile belirtilir, örneğin {id?}. Week 4 materyalinde (sayfa 30), bu özellik açıklanmıştır.",
        },
        {
          question: "IUrlHelper’ın temel amacı nedir?",
          options: [
            "A) Servisleri DI Konteynerine kaydetmek",
            "B) Rotalara göre dinamik URL’ler oluşturmak",
            "C) HTTP isteklerini yönlendirmek",
            "D) Bağımlılıkları çözümlemek",
            "E) Veritabanı bağlantılarını yönetmek",
          ],
          correct: "B) Rotalara göre dinamik URL’ler oluşturmak",
          explanation:
            "IUrlHelper, rotalara dayalı olarak dinamik URL’ler oluşturmak için kullanılır. Week 4 materyalinde (sayfa 32), bu işlev detaylandırılmıştır.",
        },
        {
          question:
            "Singleton servislerde dikkat edilmesi gereken bir durum nedir?",
          options: [
            "A) Her istekte yeni bir örnek oluşturulur",
            "B) Değiştirilebilir paylaşılan durumda iş parçacığı güvenliği",
            "C) HTTP isteği başına bir kez oluşturulur",
            "D) Test edilebilirliği azaltır",
            "E) Hafif işlemler için uygundur",
          ],
          correct:
            "B) Değiştirilebilir paylaşılan durumda iş parçacığı güvenliği",
          explanation:
            "Singleton servisler tüm istekler arasında paylaşıldığı için, değiştirilebilir durumda iş parçacığı güvenliğine dikkat edilmelidir. Week 4 materyalinde (sayfa 11), bu uyarı verilmiştir.",
        },
        {
          question: "Hangi yaşam döngüsü veritabanı bağlamları için idealdir?",
          options: [
            "A) Transient",
            "B) Scoped",
            "C) Singleton",
            "D) Static",
            "E) Disposable",
          ],
          correct: "B) Scoped",
          explanation:
            "Scoped yaşam döngüsü, HTTP isteği içinde durum koruması gereken veritabanı bağlamları (örneğin, DbContext) için idealdir. Week 4 materyalinde (sayfa 8), bu kullanım örneği verilmiştir.",
        },
        {
          question:
            "Geleneksel ve Öznitelik Yönlendirmesi arasındaki temel fark nedir?",
          options: [
            "A) Geleneksel yönlendirme daha fazla kontrol sağlar",
            "B) Öznitelik yönlendirme Program.cs’de tanımlanır",
            "C) Geleneksel yönlendirme merkezi bir konumda, öznitelik yönlendirme ise kontrolcülerde tanımlanır",
            "D) Öznitelik yönlendirme yalnızca GET isteklerini destekler",
            "E) Geleneksel yönlendirme parametreleri desteklemez",
          ],
          correct:
            "C) Geleneksel yönlendirme merkezi bir konumda, öznitelik yönlendirme ise kontrolcülerde tanımlanır",
          explanation:
            "Geleneksel Yönlendirme Program.cs’de merkezi olarak, Öznitelik Yönlendirme ise kontrolcü ve eylemler üzerinde tanımlanır. Week 4 materyalinde (sayfa 22), bu fark belirtilmiştir.",
        },
        {
          question: "Rota şablonlarında literal segment neyi ifade eder?",
          options: [
            "A) Değişken bir parametreyi",
            "B) URL’nin sabit bir kısmını",
            "C) İsteğe bağlı bir değeri",
            "D) Kısıtlanmış bir tipi",
            "E) Dinamik bir bağlantıyı",
          ],
          correct: "B) URL’nin sabit bir kısmını",
          explanation:
            "Literal segmentler, rota şablonlarında URL’nin sabit kısımlarını (örneğin, ‘api’) ifade eder. Week 4 materyalinde (sayfa 30), bu tanım verilmiştir.",
        },
        {
          question: "Hangi yöntem kontrolcüde URL oluşturmak için kullanılır?",
          options: [
            "A) Url.Action",
            "B) Route.Map",
            "C) Http.Get",
            "D) Service.Generate",
            "E) Endpoint.Create",
          ],
          correct: "A) Url.Action",
          explanation:
            "Url.Action metodu, IUrlHelper aracılığıyla kontrolcüde belirli bir eyleme URL oluşturmak için kullanılır. Week 4 materyalinde (sayfa 33), bu yöntem örneğiyle gösterilmiştir.",
        },
        {
          question: "Transient servisler hangi durumda kaynak yoğun olabilir?",
          options: [
            "A) HTTP isteği başına bir kez oluşturulduğunda",
            "B) Oluşturma maliyeti yüksekse ve sıkça istenirse",
            "C) Uygulama genelinde paylaşıldığında",
            "D) Durum koruması gerektiğinde",
            "E) Test sırasında kullanıldığında",
          ],
          correct: "B) Oluşturma maliyeti yüksekse ve sıkça istenirse",
          explanation:
            "Transient servisler her istendiğinde yeni örnek oluşturduğu için, oluşturma maliyeti yüksekse kaynak yoğun olabilir. Week 4 materyalinde (sayfa 5), bu durum belirtilmiştir.",
        },
        {
          question: "Yönlendirme ara yazılımı sırasının önemi nedir?",
          options: [
            "A) Performansı artırmak için",
            "B) UseRouting ve UseEndpoints’in doğru sırada olması gerektiği için",
            "C) Bağımlılıkları enjekte etmek için",
            "D) Yalnızca geliştirme ortamında önemlidir",
            "E) Servis yaşam döngüsünü etkiler",
          ],
          correct:
            "B) UseRouting ve UseEndpoints’in doğru sırada olması gerektiği için",
          explanation:
            "Yönlendirme ara yazılımı (UseRouting ve UseEndpoints) doğru sırada olmalıdır, yoksa eşleştirme başarısız olabilir. Week 4 materyalinde (sayfa 35), bu sorun hata ayıklama bölümünde vurgulanmıştır.",
        },
        {
          question:
            "Hangi DI yöntemi bir sınıfın bağımlılıklarını açıkça gösterir?",
          options: [
            "A) Özellik Enjeksiyonu",
            "B) Metot Enjeksiyonu",
            "C) Yapıcı Enjeksiyonu",
            "D) Manuel Çözümleme",
            "E) Statik Enjeksiyon",
          ],
          correct: "C) Yapıcı Enjeksiyonu",
          explanation:
            "Yapıcı Enjeksiyonu, bağımlılıkları yapıcının parametrelerinde açıkça göstererek netlik sağlar. Week 4 materyalinde (sayfa 13), bu avantaj vurgulanmıştır.",
        },
      ];

      let currentModel = modelA;
      let currentQuestionIndex = 0;
      let selectedAnswer = null;
      let score = { correct: 0, wrong: 0, attempted: 0 };
      let tracking = Array(currentModel.length).fill(null);

      function loadQuestion() {
        const q = currentModel[currentQuestionIndex];
        const container = document.getElementById("question-container");
        container.innerHTML = `<p>${currentQuestionIndex + 1}. ${
          q.question
        }</p>`;
        q.options.forEach((option, index) => {
          container.innerHTML += `
                          <div class="option">
                              <input type="radio" name="answer" id="option${index}" value="${option}">
                              <label for="option${index}">${option}</label>
                          </div>`;
        });
        document.getElementById("result").style.display = "none";
        document.getElementById("explanation").style.display = "none";
        document.getElementById("prev-btn").disabled =
          currentQuestionIndex === 0;
        document.getElementById("next-btn").disabled =
          currentQuestionIndex === currentModel.length - 1;
        selectedAnswer = null;
        updateTrackingTable();
      }

      function submitAnswer() {
        const selected = document.querySelector('input[name="answer"]:checked');
        if (!selected) {
          alert("Lütfen bir cevap seçin!");
          return;
        }
        selectedAnswer = selected.value;
        const q = currentModel[currentQuestionIndex];
        const result = document.getElementById("result");
        const explanation = document.getElementById("explanation");
        result.style.display = "block";
        explanation.style.display = "block";
        const isCorrect = selectedAnswer === q.correct;
        if (isCorrect) {
          result.textContent = "Doğru! Cevap: " + q.correct;
          result.className = "correct";
          if (tracking[currentQuestionIndex] === null) score.correct++;
        } else {
          result.textContent = "Yanlış! Doğru cevap: " + q.correct;
          result.className = "wrong";
          if (tracking[currentQuestionIndex] === null) score.wrong++;
        }
        explanation.textContent = "Açıklama: " + q.explanation;
        if (tracking[currentQuestionIndex] === null) {
          score.attempted++;
          tracking[currentQuestionIndex] = isCorrect;
        }
        updateScoreTable();
        updateTrackingTable();
        checkFinalScore();
      }

      function nextQuestion() {
        if (currentQuestionIndex < currentModel.length - 1) {
          currentQuestionIndex++;
          loadQuestion();
        }
      }

      function prevQuestion() {
        if (currentQuestionIndex > 0) {
          currentQuestionIndex--;
          loadQuestion();
        }
      }

      function updateScoreTable() {
        document.getElementById("correct-count").textContent = score.correct;
        document.getElementById("wrong-count").textContent = score.wrong;
        document.getElementById("attempted-count").textContent =
          score.attempted;
      }

      function updateTrackingTable() {
        const tbody = document.getElementById("tracking-body");
        tbody.innerHTML = "";
        currentModel.forEach((_, index) => {
          const status =
            tracking[index] === null
              ? "Denenmedi"
              : tracking[index]
              ? "Doğru"
              : "Yanlış";
          const className =
            tracking[index] === null
              ? "unattempted"
              : tracking[index]
              ? "correct"
              : "wrong";
          tbody.innerHTML += `<tr class="${className}"><td>${
            index + 1
          }</td><td>${status}</td></tr>`;
        });
      }

      function checkFinalScore() {
        if (score.attempted === currentModel.length) {
          const finalScore = document.getElementById("final-score");
          finalScore.style.display = "block";
          document.getElementById(
            "final-score-text"
          ).textContent = `Sonuç: ${score.correct} doğru, ${score.wrong} yanlış, Toplam: ${currentModel.length} soru`;
        }
      }

      function resetQuiz() {
        currentQuestionIndex = 0;
        score = { correct: 0, wrong: 0, attempted: 0 };
        tracking = Array(currentModel.length).fill(null);
        loadQuestion();
        updateScoreTable();
        updateTrackingTable();
        document.getElementById("final-score").style.display = "none";
      }

      function changeModel() {
        const modelSelect = document.getElementById("model-select").value;

        if ((currentModel = modelSelect === "A")) {
          currentModel = modelA;
        } else if ((currentModel = modelSelect === "B")) {
          currentModel = modelB;
        } else if ((currentModel = modelSelect === "C")) {
          currentModel = modelC;
        } else if ((currentModel = modelSelect === "D")) {
          currentModel = modelD;
        }

        resetQuiz();
      }

      window.onload = () => {
        loadQuestion();
        updateTrackingTable();
      };
    </script>
  </body>
</html>
